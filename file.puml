@startuml

package "frame" {
	class "CommonInformationEntry" as frame.CommonInformationEntry <<V,Orchid>> {
		+Length: uint32
		+CIE_id: uint32
		+Version: uint8
		+Augmentation: string
		+CodeAlignmentFactor: uint64
		+DataAlignmentFactor: int64
		+ReturnAddressRegister: uint64
		+InitialInstructions: []byte
		-staticBase: uint64
	}
}


package "frame" {
	class "DWRule" as frame.DWRule <<V,Orchid>> {
		+Rule: frame.Rule
		+Offset: int64
		+Reg: uint64
		+Expression: []byte
	}
}

	frame.DWRule --> frame.Rule


package "frame" {
	class "FrameContext" as frame.FrameContext <<E,#FFCC00>> {
		-loc: uint64
		-order: binary.ByteOrder
		-address: uint64
		+CFA: frame.DWRule
		+Regs: map[uint64]frame.DWRule
		-initialRegs: map[uint64]frame.DWRule
		-prevRegs: map[uint64]frame.DWRule
		-buf: *bytes.Buffer
		-cie: *frame.CommonInformationEntry
		+RetAddrReg: uint64
		-codeAlignment: uint64
		-dataAlignment: int64
		-executeDwarfProgram()
		+ExecuteUntilPC(instructions: []byte)
	}
}

	frame.FrameContext --> frame.DWRule
	frame.FrameContext --> frame.CommonInformationEntry


package "frame" {
	class "FrameDescriptionEntries" as frame.FrameDescriptionEntries <<V,Orchid>> {
		+FDEForPC(pc: uint64): (*frame.FrameDescriptionEntry, error)
		+Append(otherFDEs: frame.FrameDescriptionEntries): frame.FrameDescriptionEntries
	}
}

	frame.FrameDescriptionEntries ..> frame.FrameDescriptionEntry : <<return>>
	frame.FrameDescriptionEntries ..> frame.FrameDescriptionEntries

package "frame" {
	class "FrameDescriptionEntry" as frame.FrameDescriptionEntry <<V,Orchid>> {
		+Length: uint32
		+CIE: *frame.CommonInformationEntry
		+Instructions: []byte
		-begin: uint64
		-size: uint64
		-order: binary.ByteOrder
		+Cover(addr: uint64): bool
		+Begin(): uint64
		+End(): uint64
		+EstablishFrame(pc: uint64): *frame.FrameContext
	}
}

	frame.FrameDescriptionEntry --> frame.CommonInformationEntry
	frame.FrameDescriptionEntry ..> frame.FrameContext : <<return>>

package "frame" {
	class "Rule" as frame.Rule <<V,Orchid>>
}

package "frame" {
	class "instruction" as frame.instruction <<V,Orchid>> {
		-instruction(frame: *frame.FrameContext)
	}
}



package "frame" {
	class "parseContext" as frame.parseContext <<V,Orchid>> {
		-staticBase: uint64
		-buf: *bytes.Buffer
		-entries: frame.FrameDescriptionEntries
		-common: *frame.CommonInformationEntry
		-frame: *frame.FrameDescriptionEntry
		-length: uint32
		-ptrSize: int
	}
}

	frame.parseContext --> frame.FrameDescriptionEntries
	frame.parseContext --> frame.CommonInformationEntry
	frame.parseContext --> frame.FrameDescriptionEntry


package "frame" {
	class "parsefunc" as frame.parsefunc <<V,Orchid>> {
		-parsefunc(: *frame.parseContext): frame.parsefunc
	}
}

package "proc" {
	class "Ancestor" as proc.Ancestor <<V,Orchid>> {
		+ID: int64
		+Unreadable: error
		-pcsVar: *proc.Variable
		+Stack(n: int): ([]proc.Stackframe, error)
	}
}

	proc.Ancestor --> proc.Variable
	proc.Ancestor ..> proc.Stackframe : <<return>>

package "proc" {
	class "Arch" as proc.Arch <<V,Orchid>> {
		+Name: string
		-ptrSize: int
		-maxInstructionLength: int
		-prologues: []proc.opcodeSeq
		-breakpointInstruction: []byte
		-altBreakpointInstruction: []byte
		-breakInstrMovesPC: bool
		-derefTLS: bool
		-usesLR: bool
		-asmDecode: func(asmInst *proc.AsmInstruction, mem []byte, regs proc.Registers, memrw proc.MemoryReadWriter, bi *proc.BinaryInfo) error
		-fixFrameUnwindContext: frame.FrameContext
		-switchStack: op.DwarfRegisters) bool
		-regSize: func(uint64) int
		+RegistersToDwarfRegisters: op.DwarfRegisters
		-addrAndStackRegsToDwarfRegisters: op.DwarfRegisters
		+DwarfRegisterToString: op.DwarfRegister) (string, bool, string)
		-inhibitStepInto: func(bi *proc.BinaryInfo, pc uint64) bool
		-crosscall2fn: *proc.Function
		-sigreturnfn: *proc.Function
		+PtrSize(): int
		+MaxInstructionLength(): int
		+BreakpointInstruction(): []byte
		+AltBreakpointInstruction(): []byte
		+BreakInstrMovesPC(): bool
		+BreakpointSize(): int
		+DerefTLS(): bool
	}
}

	proc.Arch --> proc.opcodeSeq
	proc.Arch --> proc.Function


package "proc" {
	class "AsmInstruction" as proc.AsmInstruction <<V,Orchid>> {
		+Loc: proc.Location
		+DestLoc: *proc.Location
		+Bytes: []byte
		+Breakpoint: bool
		+AtPC: bool
		+Size: int
		+Kind: proc.AsmInstructionKind
		+Inst: proc.archInst
		+IsCall(): bool
		+IsRet(): bool
		+IsJmp(): bool
		+IsHardBreak(): bool
		+Text(flavour: proc.AssemblyFlavour, bi: *proc.BinaryInfo): string
	}
}

	proc.AsmInstruction --> proc.Location
	proc.AsmInstruction --> proc.AsmInstructionKind
	proc.AsmInstruction --> proc.archInst

	proc.AsmInstruction ..> proc.AssemblyFlavour : <<use>> 
	proc.AsmInstruction ..> proc.BinaryInfo : <<use>> 

package "proc" {
	class "AsmInstructionKind" as proc.AsmInstructionKind <<V,Orchid>>
}



package "proc" {
	class "AssemblyFlavour" as proc.AssemblyFlavour <<V,Orchid>>
}



package "proc" {
	class "BinaryInfo" as proc.BinaryInfo <<E,#FFCC00>> {
		+Arch: *proc.Arch
		+GOOS: string
		-debugInfoDirectories: []string
		+Functions: []proc.Function
		+Sources: []string
		+LookupFunc: map[string]*proc.Function
		+SymNames: elf.Symbol
		+Images: []*proc.Image
		+ElfDynamicSection: proc.ElfDynamicSection
		-lastModified: time.Time
		-closer: io.Closer
		-sepDebugCloser: io.Closer
		+PackageMap: map[string][]string
		-frameEntries: frame.FrameDescriptionEntries
		-types: map[string]proc.dwarfRef
		-packageVars: []proc.packageVar
		-gStructOffset: uint64
		-nameOfRuntimeType: map[uint64]proc.nameOfRuntimeTypeEntry
		-consts: proc.constantsMap
		-inlinedCallLines: map[proc.fileLine][]uint64
		-logger: logrus.Entry
		+LoadBinaryInfo(path: string, entryPoint: uint64, debugInfoDirs: []string): error
		+GStructOffset(): uint64
		+LastModified(): time.Time
		+Types(): ([]string, error)
		+PCToLine(pc: uint64): (string, int, *proc.Function)
		+LineToPC(filename: string, lineno: int): (pcs: []uint64, err: error)
		+AllPCsForFileLines(filename: string, linenos: []int): map[int][]uint64
		+PCToFunc(pc: uint64): *proc.Function
		+PCToInlineFunc(pc: uint64): *proc.Function
		+PCToImage(pc: uint64): *proc.Image
		+AddImage(path: string, addr: uint64): error
		-moduleDataToImage(md: *proc.moduleData): *proc.Image
		-imageToModuleData(image: *proc.Image, mds: []proc.moduleData): *proc.moduleData
		-typeToImage(typ: godwarf.Type): *proc.Image
		+Close(): error
		+LoadImageFromData(dwdata: dwarf.Data, debugFrameBytes: []byte, debugLineBytes: []byte, debugLocBytes: []byte)
		-locationExpr(entry: godwarf.Entry, attr: dwarf.Attr, pc: uint64): ([]byte, *proc.locationExpr, error)
		+LocationCovers(entry: dwarf.Entry, attr: dwarf.Attr): ([][2]uint64, error)
		+Location(entry: godwarf.Entry, attr: dwarf.Attr, pc: uint64, regs: op.DwarfRegisters): (int64, op.Piece, *proc.locationExpr, error)
		-loclistEntry(off: int64, pc: uint64): []byte
		-findCompileUnit(pc: uint64): *proc.compileUnit
		+Producer(): string
		-funcToImage(fn: *proc.Function): *proc.Image
		-openSeparateDebugInfo(image: *proc.Image, exe: elf.File, debugInfoDirectories: []string): (*os.File, elf.File, error)
		-loadSymbolName(image: *proc.Image, file: elf.File, wg: *sync.WaitGroup)
		-parseDebugFrameElf(image: *proc.Image, exe: elf.File, debugInfoBytes: []byte, wg: *sync.WaitGroup)
		-setGStructOffsetElf(image: *proc.Image, exe: elf.File, wg: *sync.WaitGroup)
		-parseDebugFramePE(image: *proc.Image, exe: pe.File, debugInfoBytes: []byte, wg: *sync.WaitGroup)
		-setGStructOffsetMacho()
		-parseDebugFrameMacho(image: *proc.Image, exe: macho.File, debugInfoBytes: []byte, wg: *sync.WaitGroup)
		-findType(name: string): (godwarf.Type, error)
		-findTypeExpr(expr: ast.Expr): (godwarf.Type, error)
		-findArrayType(n: int, etyp: string): (godwarf.Type, error)
		-registerTypeToPackageMap(entry: dwarf.Entry)
		-loadDebugInfoMaps(image: *proc.Image, debugInfoBytes: []byte, debugLineBytes: []byte, wg: *sync.WaitGroup, cont: func())
		-loadDebugInfoMapsCompileUnit(ctxt: *proc.loadDebugInfoMapsContext, image: *proc.Image, reader: reader.Reader, cu: *proc.compileUnit)
		-loadDebugInfoMapsImportedUnit(entry: dwarf.Entry, ctxt: *proc.loadDebugInfoMapsContext, image: *proc.Image, cu: *proc.compileUnit)
		-addAbstractSubprogram(entry: dwarf.Entry, ctxt: *proc.loadDebugInfoMapsContext, reader: reader.Reader, image: *proc.Image, cu: *proc.compileUnit)
		-addConcreteInlinedSubprogram(entry: dwarf.Entry, originOffset: dwarf.Offset, ctxt: *proc.loadDebugInfoMapsContext, reader: reader.Reader, cu: *proc.compileUnit)
		-addConcreteSubprogram(entry: dwarf.Entry, ctxt: *proc.loadDebugInfoMapsContext, reader: reader.Reader, cu: *proc.compileUnit)
		-loadDebugInfoMapsInlinedCalls(ctxt: *proc.loadDebugInfoMapsContext, reader: reader.Reader, cu: *proc.compileUnit)
		-expandPackagesInType(expr: ast.Expr)
		-symLookup(addr: uint64): (string, uint64)
		+ListPackagesBuildInfo(includeFiles: bool): []*proc.PackageBuildInfo
	}
}


	proc.BinaryInfo --> frame.FrameDescriptionEntries
	proc.BinaryInfo --> logrus.Entry
	proc.BinaryInfo --> proc.Arch
	proc.BinaryInfo --> proc.ElfDynamicSection
	proc.BinaryInfo --> proc.Function
	proc.BinaryInfo --> proc.constantsMap
	proc.BinaryInfo --> proc.dwarfRef
	proc.BinaryInfo --> proc.nameOfRuntimeTypeEntry
	proc.BinaryInfo --> proc.packageVar
	proc.BinaryInfo --> time.Time
	proc.BinaryInfo ..> dwarf.Attr
	proc.BinaryInfo ..> godwarf.Entry
	proc.BinaryInfo ..> op.DwarfRegisters
	proc.BinaryInfo ..> op.Piece
	proc.BinaryInfo ..> proc.Function
	proc.BinaryInfo ..> proc.Image
	proc.BinaryInfo ..> proc.locationExpr
	proc.BinaryInfo ..> time.Time

package "proc" {
	class "Breakpoint" as proc.Breakpoint <<V,Orchid>> {
		+FunctionName: string
		+File: string
		+Line: int
		+Addr: uint64
		+OriginalData: []byte
		+Name: string
		+LogicalID: int
		+Kind: proc.BreakpointKind
		+Tracepoint: bool
		+TraceReturn: bool
		+Goroutine: bool
		+Stacktrace: int
		+Variables: []string
		+LoadArgs: *proc.LoadConfig
		+LoadLocals: *proc.LoadConfig
		+HitCount: map[int]uint64
		+TotalHitCount: uint64
		+DeferReturns: []uint64
		+Cond: ast.Expr
		-internalCond: ast.Expr
		-returnInfo: *proc.returnBreakpointInfo
		+String(): string
		+CheckCondition(thread: proc.Thread): proc.BreakpointState
		+IsInternal(): bool
		+IsUser(): bool
	}
}

	proc.Breakpoint --> proc.BreakpointKind
	proc.Breakpoint --> proc.LoadConfig
	proc.Breakpoint --> proc.returnBreakpointInfo

	proc.Breakpoint ..> proc.Thread : <<use>> 
	proc.Breakpoint ..> proc.BreakpointState : <<return>> 

package "proc" {
	class "BreakpointExistsError" as proc.BreakpointExistsError <<V,Orchid>> {
		+File: string
		+Line: int
		+Addr: uint64
		+Error(): string
	}
}



package "proc" {
	class "BreakpointKind" as proc.BreakpointKind <<V,Orchid>>
}



package "proc" {
	class "BreakpointMap" as proc.BreakpointMap <<V,Orchid>> {
		+M: map[uint64]*proc.Breakpoint
		-breakpointIDCounter: int
		-internalBreakpointIDCounter: int
		+HasInternalBreakpoints(): bool
	}
}



package "proc" {
	class "BreakpointState" as proc.BreakpointState <<E,#FFCC00>> {
		+Breakpoint: *proc.Breakpoint
		+Active: bool
		+Internal: bool
		+CondError: error
		+Clear()
		+String(): string
	}
}

	proc.BreakpointState --> proc.Breakpoint


package "proc" {
	class "Checkpoint" as proc.Checkpoint <<V,Orchid>> {
		+ID: int
		+When: string
		+Where: string
	}
}



package "proc" {
	class "CommonThread" as proc.CommonThread <<V,Orchid>> {
		+CallReturn: bool
		-returnValues: []*proc.Variable
		-g: *proc.G
		+ReturnValues(cfg: proc.LoadConfig): []*proc.Variable
	}
}

	proc.CommonThread --> proc.G

	proc.CommonThread ..> proc.LoadConfig : <<use>> 

package "proc" {
	interface "CpuArch" as proc.CpuArch {
		+String(): string
	}
}



package "proc" {
	class "Defer" as proc.Defer <<E,#FFCC00>> {
		+DeferredPC: uint64
		+DeferPC: uint64
		+SP: uint64
		-link: *proc.Defer
		-argSz: int64
		-variable: *proc.Variable
		+Unreadable: error
		-load()
		+Next(): *proc.Defer
		+EvalScope(thread: proc.Thread): (*proc.EvalScope, error)
	}
}

	proc.Defer --> proc.Defer
	proc.Defer --> proc.Variable

	proc.Defer ..> proc.Defer : <<return>> 
	proc.Defer ..> proc.Thread : <<use>> 
	proc.Defer ..> proc.EvalScope : <<return>> 

package "proc" {
	class "Direction" as proc.Direction <<V,Orchid>>
}



package "proc" {
	class "ElfDynamicSection" as proc.ElfDynamicSection <<V,Orchid>> {
		+Addr: uint64
		+Size: uint64
	}
}


package "proc" {
	class "EvalScope" as proc.EvalScope <<E,#FFCC00>> {
		+Location: proc.Location
		+Regs: op.DwarfRegisters
		+Mem: proc.MemoryReadWriter
		-g: *proc.G
		+BinInfo: *proc.BinaryInfo
		-frameOffset: int64
		-aordr: dwarf.Reader
		-callCtx: *proc.callContext
		-trustArgOrder: bool
		+EvalExpression(expr: string, cfg: proc.LoadConfig): (*proc.Variable, error)
		+Locals(): ([]*proc.Variable, error)
		-setValue(dstv: *proc.Variable, srcv: *proc.Variable, srcExpr: string): error
		+EvalVariable(name: string, cfg: proc.LoadConfig): (*proc.Variable, error)
		+SetVariable(name: string, value: string): error
		+LocalVariables(cfg: proc.LoadConfig): ([]*proc.Variable, error)
		+FunctionArguments(cfg: proc.LoadConfig): ([]*proc.Variable, error)
		+PackageVariables(cfg: proc.LoadConfig): ([]*proc.Variable, error)
		-findGlobal(pkgName: string, varName: string): (*proc.Variable, error)
		-findGlobalInternal(name: string): (*proc.Variable, error)
		-image(): *proc.Image
		-globalFor(image: *proc.Image): *proc.EvalScope
		+DwarfReader(): reader.Reader
		+PtrSize(): int
		-evalToplevelTypeCast(t: ast.Expr, cfg: proc.LoadConfig): (*proc.Variable, error)
		-evalAST(t: ast.Expr): (*proc.Variable, error)
		-evalTypeCast(node: ast.CallExpr): (*proc.Variable, error)
		-evalBuiltinCall(node: ast.CallExpr): (*proc.Variable, error)
		-evalIdent(node: ast.Ident): (*proc.Variable, error)
		-evalStructSelector(node: ast.SelectorExpr): (*proc.Variable, error)
		-evalTypeAssert(node: ast.TypeAssertExpr): (*proc.Variable, error)
		-evalIndex(node: ast.IndexExpr): (*proc.Variable, error)
		-evalReslice(node: ast.SliceExpr): (*proc.Variable, error)
		-evalPointerDeref(node: ast.StarExpr): (*proc.Variable, error)
		-evalAddrOf(node: ast.UnaryExpr): (*proc.Variable, error)
		-evalUnary(node: ast.UnaryExpr): (*proc.Variable, error)
		-evalBinary(node: ast.BinaryExpr): (*proc.Variable, error)
	}
}

	proc.EvalScope --> proc.Location
	proc.EvalScope --> op.DwarfRegisters
	proc.EvalScope --> proc.MemoryReadWriter
	proc.EvalScope --> proc.G
	proc.EvalScope --> proc.BinaryInfo
	proc.EvalScope --> proc.callContext

	proc.EvalScope ..> proc.LoadConfig : <<use>> 
	proc.EvalScope ..> proc.Variable : <<return>> 
	proc.EvalScope ..> reader.Reader : <<return>>

package "proc" {
	class "Function" as proc.Function <<V,Orchid>> {
		+Name: string
		+Entry: uint64
		+End: uint64
		-offset: dwarf.Offset
		-cu: *proc.compileUnit
		+InlinedCalls: []proc.InlinedCall
		-fakeType(bi: *proc.BinaryInfo, removeReceiver: bool): (godwarf.FuncType, error)
		+PackageName(): string
		+ReceiverName(): string
		+BaseName(): string
		+Optimized(): bool
		+PrologueEndPC(): uint64
		-exportedRuntime(): bool
		-privateRuntime(): bool
	}
}

	proc.Function --> proc.compileUnit
	proc.Function --> proc.InlinedCall

package "proc" {
	class "G" as proc.G <<E,#FFCC00>> {
		+ID: int
		+PC: uint64
		+SP: uint64
		+BP: uint64
		+LR: uint64
		+GoPC: uint64
		+StartPC: uint64
		+Status: uint64
		-stkbarVar: *proc.Variable
		-stkbarPos: int
		-stack: proc.stack
		+WaitSince: int64
		+WaitReason: int64
		+SystemStack: bool
		+CurrentLoc: proc.Location
		+Thread: proc.Thread
		-variable: *proc.Variable
		+Unreadable: error
		-labels: *map[string]string
		-stackIterator(opts: proc.StacktraceOptions): (*proc.stackIterator, error)
		+Stacktrace(depth: int, opts: proc.StacktraceOptions): ([]proc.Stackframe, error)
		-readDefers(frames: []proc.Stackframe)
		+Defer(): *proc.Defer
		+UserCurrent(): proc.Location
		+Go(): proc.Location
		+StartLoc(): proc.Location
		+Labels(): map[string]string
		-stkbar(): ([]proc.savedLR, error)
	}
}

	proc.G --> proc.Variable
	proc.G --> proc.stack
	proc.G --> proc.Location
	proc.G --> proc.Thread
	proc.G --> proc.Variable
	proc.G --> error

	proc.G ..> proc.StacktraceOptions : <<use>> 
	proc.G ..> proc.Stackframe : <<return>> 
	proc.G ..> proc.Defer : <<return>>

package "proc" {
	class "Image" as proc.Image <<E,#FFCC00>> {
		+Path: string
		+StaticBase: uint64
		-addr: uint64
		-index: int
		-closer: io.Closer
		-sepDebugCloser: io.Closer
		-dwarf: dwarf.Data
		-dwarfReader: dwarf.Reader
		-loclist2: loclist.Dwarf2Reader
		-loclist5: loclist.Dwarf5Reader
		-debugAddr: godwarf.DebugAddrSection
		-typeCache: godwarf.Type
		-compileUnits: []*proc.compileUnit
		-dwarfTreeCache: simplelru.LRU
		-runtimeTypeToDIE: map[uint64]proc.runtimeTypeDIE
		-loadErrMu: sync.Mutex
		-loadErr: error
		+DwarfReader(): reader.Reader
		-registerRuntimeTypeToDIE(entry: dwarf.Entry, ardr: reader.Reader)
		+Close(): error
		-setLoadError(fmtstr: string, args: []interface{})
		+LoadError(): error
		-getDwarfTree(off: dwarf.Offset): (godwarf.Tree, error)
		-findCompileUnitForOffset(off: dwarf.Offset): *proc.compileUnit
		+Type(offset: dwarf.Offset): (godwarf.Type, error)
	}
}

	proc.Image --> loclist.Dwarf2Reader
	proc.Image --> loclist.Dwarf5Reader
	proc.Image --> godwarf.DebugAddrSection
	proc.Image --> godwarf.Type
	proc.Image --> simplelru.LRU
	proc.Image --> proc.runtimeTypeDIE
	proc.Image --> sync.Mutex

	proc.Image ..> reader.Reader : <<return>> 
	proc.Image ..> godwarf.Type : <<return>>

package "proc" {
	interface "Info" as proc.Info {
		+BinInfo(): *proc.BinaryInfo
		+EntryPoint(): (uint64, error)
		+FindThread(threadID: int): (proc.Thread, bool)
		+Pid(): int
		+ResumeNotify(: chan<- struct{})
		+ThreadList(): []proc.Thread
		+Valid(): (bool, error)
	}
}

	proc.Info ..> proc.BinaryInfo : <<return>> 
	proc.Info ..> proc.Thread : <<return>>

package "proc" {
	class "InlinedCall" as proc.InlinedCall <<V,Orchid>> {
		-cu: *proc.compileUnit
		+LowPC: uint64
		+HighPC: uint64
	}
}

	proc.InlinedCall --> proc.compileUnit


package "proc" {
	class "LoadConfig" as proc.LoadConfig <<V,Orchid>> {
		+FollowPointers: bool
		+MaxVariableRecurse: int
		+MaxStringLen: int
		+MaxArrayValues: int
		+MaxStructFields: int
		+MaxMapBuckets: int
	}
}

package "proc" {
	class "Location" as proc.Location <<V,Orchid>> {
		+PC: uint64
		+File: string
		+Line: int
		+Fn: *proc.Function
	}
}

	proc.Location --> proc.Function


package "proc" {
	interface "MemoryReadWriter" as proc.MemoryReadWriter {
		+ReadMemory(buf: []byte, addr: uint64): (n: int, err: error)
		+WriteMemory(addr: uint64, data: []byte): (written: int, err: error)
	}
}


package "proc" {
	interface "MemoryReader" as proc.MemoryReader {
		+ReadMemory(buf: []byte, addr: uint64): (n: int, err: error)
	}
}


package "proc" {
	class "NewTargetConfig" as proc.NewTargetConfig <<V,Orchid>> {
		+Path: string
		+DebugInfoDirs: []string
		+DisableAsyncPreempt: bool
		+StopReason: proc.StopReason
	}
}

	proc.NewTargetConfig --> proc.StopReason


package "proc" {
	class "NoBreakpointError" as proc.NoBreakpointError <<V,Orchid>> {
		+Addr: uint64
		+Error(): string
	}
}



package "proc" {
	class "NullAddrError" as proc.NullAddrError <<V,Orchid>> {
		+Error(): string
	}
}



package "proc" {
	class "PEMachine" as proc.PEMachine <<V,Orchid>> {
		+String(): string
	}
}



package "proc" {
	class "PackageBuildInfo" as proc.PackageBuildInfo <<V,Orchid>> {
		+ImportPath: string
		+DirectoryPath: string
		+Files: map[string]struct{}
	}
}



package "proc" {
	interface "Process" as proc.Process {
		+BinInfo(): *proc.BinaryInfo
		+Breakpoints(): *proc.BreakpointMap
		+ChangeDirection(: proc.Direction): error
		+CheckAndClearManualStopRequest(): bool
		+Checkpoint(where: string): (id: int, err: error)
		+Checkpoints(): ([]proc.Checkpoint, error)
		+ClearCheckpoint(id: int): error
		+EntryPoint(): (uint64, error)
		+FindThread(threadID: int): (proc.Thread, bool)
		+GetDirection(): proc.Direction
		+Memory(): proc.MemoryReadWriter
		+Pid(): int
		+Recorded(): (recorded: bool, tracedir: string)
		+RequestManualStop(): error
		+ResumeNotify(: chan<- struct{})
		+ThreadList(): []proc.Thread
		+Valid(): (bool, error)
		+When(): (string, error)
	}
}


	proc.Process ..> proc.BinaryInfo : <<return>> 
	proc.Process ..> proc.BreakpointMap : <<return>> 
	proc.Process ..> proc.Direction : <<use>> 
	proc.Process ..> proc.Checkpoint : <<return>>
	proc.Process ..> proc.Thread : <<return>>
	proc.Process ..> proc.MemoryReadWriter : <<return>>

package "proc" {
	interface "ProcessInternal" as proc.ProcessInternal {
		+ContinueOnce(): (trapthread: proc.Thread, stopReason: proc.StopReason, err: error)
		+Detach(: bool): error
		+EraseBreakpoint(: *proc.Breakpoint): error
		+Restart(pos: string): (proc.Thread, error)
		+WriteBreakpoint(addr: uint64): (file: string, line: int, fn: *proc.Function, originalData: []byte, err: error)
	}
}


	proc.ProcessInternal ..> proc.Thread : <<return>> 
	proc.ProcessInternal ..> proc.StopReason : <<return>> 
	proc.ProcessInternal ..> proc.Breakpoint : <<use>>
	proc.ProcessInternal ..> proc.Function : <<return>>

package "proc" {
	interface "ProcessManipulation" as proc.ProcessManipulation {
		+CheckAndClearManualStopRequest(): bool
		+RequestManualStop(): error
	}
}


package "proc" {
	interface "RecordingManipulation" as proc.RecordingManipulation {
		+ChangeDirection(: proc.Direction): error
		+Checkpoint(where: string): (id: int, err: error)
		+Checkpoints(): ([]proc.Checkpoint, error)
		+ClearCheckpoint(id: int): error
		+GetDirection(): proc.Direction
		+Recorded(): (recorded: bool, tracedir: string)
		+When(): (string, error)
	}
}


	proc.RecordingManipulation ..> proc.Direction : <<use>> 
	proc.RecordingManipulation ..> proc.Checkpoint : <<return>>
	proc.RecordingManipulation ..> proc.Direction : <<return>>

package "proc" {
	class "Register" as proc.Register <<V,Orchid>> {
		+Name: string
		+Reg: op.DwarfRegister
	}
}

	proc.Register --> op.DwarfRegister


package "proc" {
	interface "Registers" as proc.Registers {
		+BP(): uint64
		+Copy(): (proc.Registers, error)
		+GAddr(): (uint64, bool)
		+Get(: int): (uint64, error)
		+PC(): uint64
		+SP(): uint64
		+Slice(floatingPoint: bool): ([]proc.Register, error)
		+TLS(): uint64
	}
}

	proc.Registers ..> proc.Registers : <<return>>

package "proc" {
	class "Stackframe" as proc.Stackframe <<V,Orchid>> {
		+Current: proc.Location
		+Call: proc.Location
		+Regs: op.DwarfRegisters
		-stackHi: uint64
		+Ret: uint64
		-addrret: uint64
		+Err: error
		+SystemStack: bool
		+Inlined: bool
		+Bottom: bool
		-lastpc: uint64
		+TopmostDefer: *proc.Defer
		+Defers: []*proc.Defer
		+FrameOffset(): int64
		+FramePointerOffset(): int64
	}
}

	proc.Stackframe --> proc.Location
	proc.Stackframe --> op.DwarfRegisters
	proc.Stackframe --> proc.Defer


package "proc" {
	class "StacktraceOptions" as proc.StacktraceOptions <<V,Orchid>>
}

package "proc" {
	class "StopReason" as proc.StopReason <<V,Orchid>> {
		+String(): string
	}
}


package "proc" {
	class "Target" as proc.Target <<E,#FFCC00>> {
		+Process: proc.Process
		-proc: proc.ProcessInternal
		+StopReason: proc.StopReason
		-currentThread: proc.Thread
		-selectedGoroutine: *proc.G
		-fncallForG: map[int]*proc.callInjection
		-asyncPreemptChanged: bool
		-asyncPreemptOff: int64
		-gcache: proc.goroutineCache
		+Next(): err: error
		+Continue(): error
		+Step(): err: error
		+StepOut(): error
		+StepInstruction(): err: error
		+SupportsFunctionCalls(): bool
		+ClearAllGCache()
		+Restart(from: string): error
		+SelectedGoroutine(): *proc.G
		+SwitchGoroutine(g: *proc.G): error
		+SwitchThread(tid: int): error
		+Detach(kill: bool): error
		-createUnrecoveredPanicBreakpoint()
		-createFatalThrowBreakpoint()
		+CurrentThread(): proc.Thread
		+SetBreakpoint(addr: uint64, kind: proc.BreakpointKind, cond: ast.Expr): (*proc.Breakpoint, error)
		-setBreakpointWithID(id: int, addr: uint64): (*proc.Breakpoint, error)
		+ClearBreakpoint(addr: uint64): (*proc.Breakpoint, error)
		+ClearInternalBreakpoints(): error
	}
}

	proc.Target --> proc.Process
	proc.Target --> proc.ProcessInternal
	proc.Target --> proc.StopReason
	proc.Target --> proc.Thread
	proc.Target --> proc.G
	proc.Target --> proc.goroutineCache

	proc.Target ..> proc.Thread : <<return>>
	proc.Target ..> proc.BreakpointKind : <<use>> 
	proc.Target ..> proc.Breakpoint : <<return>> 

package "proc" {
	interface "Thread" as proc.Thread {
		+BinInfo(): *proc.BinaryInfo
		+Breakpoint(): *proc.BreakpointState
		+Common(): *proc.CommonThread
		+Location(): (*proc.Location, error)
		+ProcessMemory(): proc.MemoryReadWriter
		+Registers(): (proc.Registers, error)
		+RestoreRegisters(: proc.Registers): error
		+SetCurrentBreakpoint(adjustPC: bool): error
		+SetDX(: uint64): error
		+SetPC(: uint64): error
		+SetSP(: uint64): error
		+StepInstruction(): error
		+ThreadID(): int
	}
}

	proc.Thread ..> proc.BinaryInfo : <<return>>
	proc.Thread ..> proc.BreakpointState : <<return>> 
	proc.Thread ..> proc.CommonThread : <<return>> 
	proc.Thread ..> proc.Location : <<return>> 
	proc.Thread ..> proc.MemoryReadWriter : <<return>>
	proc.Thread ..> proc.Registers : <<return>> 
	proc.Thread ..> proc.Registers : <<use>>

package "proc" {
	interface "ThreadInfo" as proc.ThreadInfo {
		+FindThread(threadID: int): (proc.Thread, bool)
		+ThreadList(): []proc.Thread
	}
}

	proc.ThreadInfo ..> proc.Thread : <<return>>

package "proc" {
	class "Variable" as proc.Variable <<E,#FFCC00>> {
		+Addr: uint64
		+OnlyAddr: bool
		+Name: string
		+DwarfType: godwarf.Type
		+RealType: godwarf.Type
		+Kind: reflect.Kind
		-mem: proc.MemoryReadWriter
		-bi: *proc.BinaryInfo
		+Value: constant.Value
		+FloatSpecial: proc.floatSpecial
		+Len: int64
		+Cap: int64
		+Flags: proc.variableFlags
		+Base: uint64
		-stride: int64
		-fieldType: godwarf.Type
		-closureAddr: uint64
		-mapSkip: int
		+Children: []proc.Variable
		-loaded: bool
		+Unreadable: error
		+LocationExpr: *proc.locationExpr
		+DeclLine: int64
		-pointerToVariable(): *proc.Variable
		-isNil(): bool
		-asInt(): (int64, error)
		-asUint(): (uint64, error)
		-isType(typ: godwarf.Type, kind: reflect.Kind): error
		-sliceAccess(idx: int): (*proc.Variable, error)
		-mapAccess(idx: *proc.Variable): (*proc.Variable, error)
		-reslice(low: int64, high: int64): (*proc.Variable, error)
		-findMethod(mname: string): (*proc.Variable, error)
		-tryFindMethodInEmbeddedFields(mname: string): (*proc.Variable, error)
		-newVariable(name: string, addr: uint64, dwarfType: godwarf.Type, mem: proc.MemoryReadWriter): *proc.Variable
		-clone(): *proc.Variable
		+TypeString(): string
		-toField(field: godwarf.StructField): (*proc.Variable, error)
		-parseG(): (*proc.G, error)
		-loadFieldNamed(name: string): *proc.Variable
		-fieldVariable(name: string): *proc.Variable
		-structMember(memberName: string): (*proc.Variable, error)
		-maybeDereference(): *proc.Variable
		-loadValue(cfg: proc.LoadConfig)
		-loadValueInternal(recurseLevel: int, cfg: proc.LoadConfig)
		-loadSliceInfo(t: godwarf.SliceType)
		-loadChanInfo()
		-loadArrayValues(recurseLevel: int, cfg: proc.LoadConfig)
		-readComplex(size: int64)
		-writeComplex(real: float64, imag: float64, size: int64): error
		-writeUint(value: uint64, size: int64): error
		-readFloatRaw(size: int64): (float64, error)
		-writeFloatRaw(f: float64, size: int64): error
		-writeBool(value: bool): error
		-writeZero(): error
		-writeEmptyInterface(typeAddr: uint64, data: *proc.Variable): error
		-writeSlice(len: int64, cap: int64, base: uint64): error
		-writeString(len: uint64, base: uint64): error
		-writeCopy(srcv: *proc.Variable): error
		-readFunctionPtr()
		-funcvalAddr(): uint64
		-loadMap(recurseLevel: int, cfg: proc.LoadConfig)
		-mapIterator(): *proc.mapIterator
		-readInterface(): (_type: *proc.Variable, data: *proc.Variable, isnil: bool)
		-loadInterface(recurseLevel: int, loadData: bool, cfg: proc.LoadConfig)
		+ConstDescr(): string
	}
}

	proc.Variable --> godwarf.Type
	proc.Variable --> proc.MemoryReadWriter
	proc.Variable --> proc.BinaryInfo
	proc.Variable --> proc.floatSpecial
	proc.Variable --> proc.variableFlags
	proc.Variable --> proc.Variable
	proc.Variable --> proc.locationExpr


package "proc" {
	interface "archInst" as proc.archInst {
		+OpcodeEquals(op: uint64): bool
		+Text(flavour: proc.AssemblyFlavour, pc: uint64, symLookup: func(uint64) (string, uint64)): string
	}
}

	proc.archInst ..> proc.AssemblyFlavour : <<use>> 

package "proc" {
	class "callContext" as proc.callContext <<E,#FFCC00>> {
		-p: *proc.Target
		-checkEscape: bool
		-retLoadCfg: proc.LoadConfig
		-continueRequest: chan<- proc.continueRequest
		-continueCompleted: <-chan *proc.G
		-injectionThread: proc.Thread
		-stacks: []proc.stack
		-doContinue(): *proc.G
		-doReturn(ret: *proc.Variable, err: error)
	}
}

	proc.callContext --> proc.Target
	proc.callContext --> proc.LoadConfig
	proc.callContext --> proc.Thread
	proc.callContext --> proc.stack


package "proc" {
	class "callInjection" as proc.callInjection <<V,Orchid>> {
		-continueCompleted: chan<- *proc.G
		-continueRequest: <-chan proc.continueRequest
		-startThreadID: int
	}
}



package "proc" {
	class "compileUnit" as proc.compileUnit <<V,Orchid>> {
		-name: string
		+Version: uint8
		-lowPC: uint64
		-ranges: [][2]uint64
		-entry: dwarf.Entry
		-isgo: bool
		-lineInfo: line.DebugLineInfo
		-optimized: bool
		-producer: string
		-offset: dwarf.Offset
		-image: *proc.Image
	}
}

	proc.compileUnit --> line.DebugLineInfo
	proc.compileUnit --> proc.Image


package "proc" {
	class "compileUnitsByOffset" as proc.compileUnitsByOffset <<V,Orchid>> {
		+Len(): int
		+Less(i: int, j: int): bool
		+Swap(i: int, j: int)
	}
}



package "proc" {
	class "compositeMemory" as proc.compositeMemory <<V,Orchid>> {
		-realmem: proc.MemoryReadWriter
		-regs: op.DwarfRegisters
		-pieces: op.Piece
		-data: []byte
		+ReadMemory(data: []byte, addr: uint64): (int, error)
		+WriteMemory(addr: uint64, data: []byte): (int, error)
	}
}

	proc.compositeMemory --> proc.MemoryReadWriter
	proc.compositeMemory --> op.DwarfRegisters
	proc.compositeMemory --> op.Piece


package "proc" {
	class "constantType" as proc.constantType <<V,Orchid>> {
		-initialized: bool
		-values: []proc.constantValue
		-describe(n: int64): string
	}
}

	proc.constantType --> proc.constantValue


package "proc" {
	class "constantValue" as proc.constantValue <<V,Orchid>> {
		-name: string
		-fullName: string
		-value: int64
		-singleBit: bool
	}
}



package "proc" {
	class "constantValuesByValue" as proc.constantValuesByValue <<V,Orchid>> {
		+Len(): int
		+Less(i: int, j: int): bool
		+Swap(i: int, j: int)
	}
}


proc.constantValuesByValue *-- proc.constantValue
package "proc" {
	class "constantsMap" as proc.constantsMap <<V,Orchid>> {
		+Get(typ: godwarf.Type): *proc.constantType
	}
}


	proc.constantsMap ..> godwarf.Type : <<use>> 
	proc.constantsMap ..> proc.constantType : <<return>> 

package "proc" {
	class "continueRequest" as proc.continueRequest <<V,Orchid>> {
		-cont: bool
		-err: error
		-ret: *proc.Variable
	}
}

	proc.continueRequest --> proc.Variable


package "proc" {
	class "dwarfRef" as proc.dwarfRef <<V,Orchid>> {
		-imageIndex: int
		-offset: dwarf.Offset
	}
}



package "proc" {
	class "fileLine" as proc.fileLine <<V,Orchid>> {
		-file: string
		-line: int
	}
}


package "proc" {
	class "funcCallArg" as proc.funcCallArg <<V,Orchid>> {
		-name: string
		-typ: godwarf.Type
		-off: int64
		-isret: bool
	}
}

	proc.funcCallArg --> godwarf.Type


package "proc" {
	class "functionCallState" as proc.functionCallState <<V,Orchid>> {
		-savedRegs: proc.Registers
		-err: error
		-expr: ast.CallExpr
		-fn: *proc.Function
		-receiver: *proc.Variable
		-closureAddr: uint64
		-formalArgs: []proc.funcCallArg
		-argFrameSize: int64
		-retvars: []*proc.Variable
		-panicvar: *proc.Variable
		-lateCallFailure: bool
		-returnValues(): []*proc.Variable
	}
}

	proc.functionCallState --> proc.Registers
	proc.functionCallState --> proc.Function
	proc.functionCallState --> proc.funcCallArg
	proc.functionCallState --> proc.Variable


package "proc" {
	class "functionsDebugInfoByEntry" as proc.functionsDebugInfoByEntry <<V,Orchid>> {
		+Len(): int
		+Less(i: int, j: int): bool
		+Swap(i: int, j: int)
	}
}


proc.functionsDebugInfoByEntry *-- proc.Function
package "proc" {
	class "goroutineCache" as proc.goroutineCache <<E,#FFCC00>> {
		-partialGCache: map[int]*proc.G
		-allGCache: []*proc.G
		-allgentryAddr: uint64
		-allglenAddr: uint64
		-init(bi: *proc.BinaryInfo)
		-getRuntimeAllg(bi: *proc.BinaryInfo, mem: proc.MemoryReadWriter): (uint64, uint64, error)
		-addGoroutine(g: *proc.G)
		+Clear()
	}
}



package "proc" {
	class "loadDebugInfoMapsContext" as proc.loadDebugInfoMapsContext <<V,Orchid>> {
		-ardr: reader.Reader
		-abstractOriginTable: dwarf.Offset]int
		-knownPackageVars: map[string]struct{}
		-offsetToVersion: dwarf.Offset]uint8
	}
}

	proc.loadDebugInfoMapsContext --> reader.Reader


package "proc" {
	class "locationExpr" as proc.locationExpr <<V,Orchid>> {
		-isBlock: bool
		-isEscaped: bool
		-off: int64
		-pc: uint64
		-instr: []byte
		+String(): string
	}
}



package "proc" {
	class "mapIterator" as proc.mapIterator <<V,Orchid>> {
		-v: *proc.Variable
		-numbuckets: uint64
		-oldmask: uint64
		-buckets: *proc.Variable
		-oldbuckets: *proc.Variable
		-b: *proc.Variable
		-bidx: uint64
		-tophashes: *proc.Variable
		-keys: *proc.Variable
		-values: *proc.Variable
		-overflow: *proc.Variable
		-maxNumBuckets: uint64
		-idx: int64
		-hashTophashEmptyOne: uint64
		-hashMinTopHash: uint64
		-nextBucket(): bool
		-next(): bool
		-key(): *proc.Variable
		-value(): *proc.Variable
		-mapEvacuated(b: *proc.Variable): bool
	}
}

	proc.mapIterator --> proc.Variable

package "proc" {
	class "memCache" as proc.memCache <<V,Orchid>> {
		-loaded: bool
		-cacheAddr: uint64
		-cache: []byte
		-mem: proc.MemoryReadWriter
		-contains(addr: uint64, size: int): bool
		+ReadMemory(data: []byte, addr: uint64): (n: int, err: error)
		+WriteMemory(addr: uint64, data: []byte): (written: int, err: error)
	}
}

	proc.memCache --> proc.MemoryReadWriter
	proc.memCache ..> error : <<return>>

package "proc" {
	class "moduleData" as proc.moduleData <<V,Orchid>> {
		-text: uint64
		-etext: uint64
		-types: uint64
		-etypes: uint64
		-typemapVar: *proc.Variable
	}
}

	proc.moduleData --> proc.Variable


package "proc" {
	class "nameOfRuntimeTypeEntry" as proc.nameOfRuntimeTypeEntry <<V,Orchid>> {
		-typename: string
		-kind: int64
	}
}


package "proc" {
	class "onNextGoroutineWalker" as proc.onNextGoroutineWalker <<V,Orchid>> {
		-thread: proc.Thread
		-ret: bool
		-err: error
		+Visit(n: ast.Node): ast.Visitor
	}
}

	proc.onNextGoroutineWalker --> proc.Thread


package "proc" {
	class "opcodeSeq" as proc.opcodeSeq <<V,Orchid>>
}



package "proc" {
	class "packageVar" as proc.packageVar <<V,Orchid>> {
		-name: string
		-cu: *proc.compileUnit
		-offset: dwarf.Offset
		-addr: uint64
	}
}

	proc.packageVar --> proc.compileUnit


package "proc" {
	class "packageVarsByAddr" as proc.packageVarsByAddr <<V,Orchid>> {
		+Len(): int
		+Less(i: int, j: int): bool
		+Swap(i: int, j: int)
	}
}


proc.packageVarsByAddr *-- proc.packageVar
package "proc" {
	class "returnBreakpointInfo" as proc.returnBreakpointInfo <<V,Orchid>> {
		-retFrameCond: ast.Expr
		-fn: *proc.Function
		-frameOffset: int64
		-spOffset: int64
		+Collect(thread: proc.Thread): []*proc.Variable
	}
}

	proc.returnBreakpointInfo --> proc.Function
	proc.returnBreakpointInfo ..> proc.Thread : <<use>>

package "proc" {
	class "runtimeTypeDIE" as proc.runtimeTypeDIE <<V,Orchid>> {
		-offset: dwarf.Offset
		-kind: int64
	}
}



package "proc" {
	class "savedLR" as proc.savedLR <<V,Orchid>> {
		-ptr: uint64
		-val: uint64
	}
}



package "proc" {
	class "stack" as proc.stack <<V,Orchid>> {
		-hi: uint64
		-lo: uint64
	}
}



package "proc" {
	class "stackIterator" as proc.stackIterator <<E,#FFCC00>> {
		-pc: uint64
		-top: bool
		-atend: bool
		-frame: proc.Stackframe
		-bi: *proc.BinaryInfo
		-mem: proc.MemoryReadWriter
		-err: error
		-stackhi: uint64
		-systemstack: bool
		-stackBarrierPC: uint64
		-stkbar: []proc.savedLR
		-regs: op.DwarfRegisters
		-g: *proc.G
		-g0_sched_sp: uint64
		-g0_sched_sp_loaded: bool
		-opts: proc.StacktraceOptions
		+Next(): bool
		-switchToGoroutineStack()
		+Frame(): proc.Stackframe
		+Err(): error
		-frameBase(fn: *proc.Function): int64
		-newStackframe(ret: uint64, retaddr: uint64): proc.Stackframe
		-stacktrace(depth: int): ([]proc.Stackframe, error)
		-appendInlineCalls(frames: []proc.Stackframe, frame: proc.Stackframe): []proc.Stackframe
		-advanceRegs(): (callFrameRegs: op.DwarfRegisters, ret: uint64, retaddr: uint64)
		-executeFrameRegRule(regnum: uint64, rule: frame.DWRule, cfa: int64): (op.DwarfRegister, error)
		-readRegisterAt(regnum: uint64, addr: uint64): (op.DwarfRegister, error)
		-loadG0SchedSP()
	}
}

	proc.stackIterator --> proc.Stackframe
	proc.stackIterator --> proc.BinaryInfo
	proc.stackIterator --> proc.MemoryReadWriter
	proc.stackIterator --> proc.savedLR
	proc.stackIterator --> op.DwarfRegisters
	proc.stackIterator --> proc.G
	proc.stackIterator --> proc.StacktraceOptions

package "proc" {
	class "typeConvErr" as proc.typeConvErr <<V,Orchid>> {
		-srcType: godwarf.Type
		-dstType: godwarf.Type
		+Error(): string
	}
}

	proc.typeConvErr --> godwarf.Type


package "proc" {
	class "variableFlags" as proc.variableFlags <<V,Orchid>>
}



package "proc" {
	class "variablesByDepthAndDeclLine" as proc.variablesByDepthAndDeclLine <<E,#FFCC00>> {
		-vars: []*proc.Variable
		-depths: []int
		+Len(): int
		+Less(i: int, j: int): bool
		+Swap(i: int, j: int)
	}
}



package "proc" {
	class "x86Inst" as proc.x86Inst <<V,Orchid>> {
		+Prefix: x86asm.Prefixes
		+Op: x86asm.Op
		+Opcode: uint32
		+Args: x86asm.Args
		+Mode: int
		+AddrSize: int
		+DataSize: int
		+MemBytes: int
		+Len: int
		+PCRel: int
		+PCRelOff: int
		+Text(flavour: proc.AssemblyFlavour, pc: uint64, symLookup: func(uint64) (string, uint64)): string
		+OpcodeEquals(op: uint64): bool
	}
}

	proc.x86Inst --> x86asm.Prefixes
	proc.x86Inst --> x86asm.Op
	proc.x86Inst --> x86asm.Args
	proc.x86Inst ..> proc.AssemblyFlavour : <<use>>


package "realname" {
	class "SomeType" as realname.SomeType <<V,Orchid>> {
		+A: bool
	}
}


package "reader" {
	class "Reader" as reader.Reader <<E,#FFCC00>> {
		+Reader: dwarf.Reader
		-depth: int
		+Seek(off: dwarf.Offset)
		+SeekToEntry(entry: dwarf.Entry): error
		+AddrFor(name: string, staticBase: uint64, ptrSize: int): (uint64, error)
		+AddrForMember(member: string, initialInstructions: []byte, ptrSize: int): (uint64, error)
		+SeekToType(entry: dwarf.Entry, resolveTypedefs: bool, resolvePointerTypes: bool): (dwarf.Entry, error)
		+NextType(): (dwarf.Entry, error)
		+SeekToTypeNamed(name: string): (dwarf.Entry, error)
		+FindEntryNamed(name: string, member: bool): (dwarf.Entry, error)
		+InstructionsForEntryNamed(name: string, member: bool): ([]byte, error)
		+InstructionsForEntry(entry: dwarf.Entry): ([]byte, error)
		+NextMemberVariable(): (dwarf.Entry, error)
		+NextPackageVariable(): (dwarf.Entry, error)
		+NextCompileUnit(): (dwarf.Entry, error)
	}
}


package "reader" {
	class "Variable" as reader.Variable <<V,Orchid>> {
		+Tree: godwarf.Tree
		+Depth: int
	}
}

	reader.Variable --> godwarf.Tree


package "reader" {
	class "VariablesFlags" as reader.VariablesFlags <<V,Orchid>>
}



package "gcimporter" {
	class "anyType" as gcimporter.anyType <<V,Orchid>> {
		+Underlying(): types.Type
		+String(): string
	}
}



package "gcimporter" {
	class "byPath" as gcimporter.byPath <<V,Orchid>> {
		+Len(): int
		+Swap(i: int, j: int)
		+Less(i: int, j: int): bool
	}
}



package "gcimporter" {
	class "dddSlice" as gcimporter.dddSlice <<V,Orchid>> {
		-elem: types.Type
		+Underlying(): types.Type
		+String(): string
	}
}



package "gcimporter" {
	class "exportWriter" as gcimporter.exportWriter <<E,#FFCC00>> {
		-p: *gcimporter.iexporter
		-data: gcimporter.intWriter
		-currPkg: types.Package
		-prevFile: string
		-prevLine: int64
		-writeIndex(index: types.Object]uint64)
		-exportPath(pkg: types.Package): string
		-tag(tag: byte)
		-pos(pos: token.Pos)
		-pkg(pkg: types.Package)
		-qualifiedIdent(obj: types.Object)
		-typ(t: types.Type, pkg: types.Package)
		-flush(): uint64
		-startType(k: gcimporter.itag)
		-doTyp(t: types.Type, pkg: types.Package)
		-setPkg(pkg: types.Package, write: bool)
		-signature(sig: types.Signature)
		-paramList(tup: types.Tuple)
		-param(obj: types.Object)
		-value(typ: types.Type, v: constant.Value)
		-mpint(x: big.Int, typ: types.Type)
		-mpfloat(f: big.Float, typ: types.Type)
		-bool(b: bool): bool
		-int64(x: int64)
		-uint64(x: uint64)
		-string(s: string)
		-localIdent(obj: types.Object)
	}
}

	gcimporter.exportWriter --> gcimporter.iexporter
	gcimporter.exportWriter --> gcimporter.intWriter


package "gcimporter" {
	class "exporter" as gcimporter.exporter <<E,#FFCC00>> {
		-fset: token.FileSet
		-out: bytes.Buffer
		-strIndex: map[string]int
		-pkgIndex: types.Package]int
		-typIndex: types.Type]int
		-posInfoFormat: bool
		-prevFile: string
		-prevLine: int
		-written: int
		-indent: int
		-pkg(pkg: types.Package, emptypath: bool)
		-obj(obj: types.Object)
		-pos(obj: types.Object)
		-fileLine(obj: types.Object): (file: string, line: int)
		-qualifiedName(obj: types.Object)
		-typ(t: types.Type)
		-assocMethods(named: types.Named)
		-fieldList(t: types.Struct)
		-field(f: types.Var)
		-iface(t: types.Interface)
		-method(m: types.Func)
		-fieldName(f: types.Var)
		-paramList(params: types.Tuple, variadic: bool)
		-value(x: constant.Value)
		-float(x: constant.Value)
		-bool(b: bool): bool
		-index(marker: byte, index: int)
		-tag(tag: int)
		-int(x: int)
		-int64(x: int64)
		-string(s: string)
		-marker(m: byte)
		-rawInt64(x: int64)
		-rawStringln(s: string)
		-rawByte(b: byte)
		-tracef(format: string, args: []interface{})
	}
}



package "gcimporter" {
	class "fakeFileSet" as gcimporter.fakeFileSet <<V,Orchid>> {
		-fset: token.FileSet
		-files: token.File
		-pos(file: string, line: int, column: int): token.Pos
	}
}



package "gcimporter" {
	class "iexporter" as gcimporter.iexporter <<E,#FFCC00>> {
		-fset: token.FileSet
		-out: *bytes.Buffer
		-localpkg: types.Package
		-allPkgs: types.Package]bool
		-declTodo: gcimporter.objQueue
		-strings: gcimporter.intWriter
		-stringIndex: map[string]uint64
		-data0: gcimporter.intWriter
		-declIndex: types.Object]uint64
		-typIndex: types.Type]uint64
		-stringOff(s: string): uint64
		-pushDecl(obj: types.Object)
		-doDecl(obj: types.Object)
		-newWriter(): *gcimporter.exportWriter
		-typOff(t: types.Type, pkg: types.Package): uint64
	}
}

	gcimporter.iexporter --> gcimporter.objQueue
	gcimporter.iexporter --> gcimporter.intWriter


package "gcimporter" {
	class "iimporter" as gcimporter.iimporter <<E,#FFCC00>> {
		-ipath: string
		-ipkg: types.Package
		-version: int
		-stringData: []byte
		-stringCache: map[uint64]string
		-pkgCache: types.Package
		-declData: []byte
		-pkgIndex: types.Package]map[string]uint64
		-typCache: types.Type
		-fake: gcimporter.fakeFileSet
		-interfaceList: types.Interface
		-doDecl(pkg: types.Package, name: string)
		-stringAt(off: uint64): string
		-pkgAt(off: uint64): types.Package
		-typAt(off: uint64, base: types.Named): types.Type
	}
}

	gcimporter.iimporter --> gcimporter.fakeFileSet


package "gcimporter" {
	class "importError" as gcimporter.importError <<V,Orchid>> {
		-pos: scanner.Position
		-err: error
		+Error(): string
	}
}


package "gcimporter" {
	class "importReader" as gcimporter.importReader <<E,#FFCC00>> {
		-p: *gcimporter.iimporter
		-declReader: bytes.Reader
		-currPkg: types.Package
		-prevFile: string
		-prevLine: int64
		-prevColumn: int64
		-obj(name: string)
		-declare(obj: types.Object)
		-value(): (typ: types.Type, val: constant.Value)
		-mpint(b: types.Basic): constant.Value
		-mpfloat(b: types.Basic): constant.Value
		-ident(): string
		-qualifiedIdent(): (types.Package, string)
		-pos(): token.Pos
		-posv0()
		-posv1()
		-typ(): types.Type
		-pkg(): types.Package
		-string(): string
		-doType(base: types.Named): types.Type
		-kind(): gcimporter.itag
		-signature(recv: types.Var): types.Signature
		-paramList(): types.Tuple
		-param(): types.Var
		-bool(): bool
		-int64(): int64
		-uint64(): uint64
		-byte(): byte
	}
}

	gcimporter.importReader --> gcimporter.iimporter


package "gcimporter" {
	class "importer" as gcimporter.importer <<E,#FFCC00>> {
		-imports: types.Package
		-data: []byte
		-importpath: string
		-buf: []byte
		-version: int
		-strList: []string
		-pathList: []string
		-pkgList: types.Package
		-typList: types.Type
		-interfaceList: types.Interface
		-trackAllTypes: bool
		-posInfoFormat: bool
		-prevFile: string
		-prevLine: int
		-fake: gcimporter.fakeFileSet
		-debugFormat: bool
		-read: int
		-pkg(): types.Package
		-declare(obj: types.Object)
		-obj(tag: int)
		-pos(): token.Pos
		-qualifiedName(): (pkg: types.Package, name: string)
		-record(t: types.Type)
		-typ(parent: types.Package, tname: types.Named): types.Type
		-fieldList(parent: types.Package): (fields: types.Var, tags: []string)
		-field(parent: types.Package): (types.Var, string)
		-methodList(parent: types.Package, baseType: types.Named): methods: types.Func
		-method(parent: types.Package, baseType: types.Named): types.Func
		-fieldName(parent: types.Package): (pkg: types.Package, name: string, alias: bool)
		-paramList(): (types.Tuple, bool)
		-param(named: bool): (types.Var, bool)
		-value(): constant.Value
		-float(): constant.Value
		-tagOrIndex(): int
		-int(): int
		-int64(): int64
		-path(): string
		-string(): string
		-marker(want: byte)
		-rawInt64(): int64
		-rawStringln(b: byte): string
		+ReadByte(): (byte, error)
		-rawByte(): byte
	}
}

	gcimporter.importer --> gcimporter.fakeFileSet

package "gcimporter" {
	class "intReader" as gcimporter.intReader <<V,Orchid>> {
		+Reader: *bytes.Reader
		-path: string
		-int64(): int64
		-uint64(): uint64
	}
}



package "gcimporter" {
	class "intWriter" as gcimporter.intWriter <<E,#FFCC00>> {
		+Buffer: bytes.Buffer
		-int64(x: int64)
		-uint64(x: uint64)
	}
}



package "gcimporter" {
	class "internalError" as gcimporter.internalError <<V,Orchid>> {
		+Error(): string
	}
}



package "gcimporter" {
	class "itag" as gcimporter.itag <<V,Orchid>>
}



package "gcimporter" {
	class "methodsByName" as gcimporter.methodsByName <<V,Orchid>> {
		+Len(): int
		+Swap(i: int, j: int)
		+Less(i: int, j: int): bool
	}
}



package "gcimporter" {
	class "objQueue" as gcimporter.objQueue <<E,#FFCC00>> {
		-ring: types.Object
		-head: int
		-tail: int
		-empty(): bool
		-pushTail(obj: types.Object)
		-popHead(): types.Object
	}
}



package "gcimporter" {
	class "parser" as gcimporter.parser <<E,#FFCC00>> {
		-scanner: scanner.Scanner
		-tok: rune
		-lit: string
		-id: string
		-sharedPkgs: types.Package
		-localPkgs: types.Package
		-init(filename: string, id: string, src: io.Reader, packages: types.Package)
		-next()
		-error(err: interface{})
		-errorf(format: string, args: []interface{})
		-expect(tok: rune): string
		-expectSpecial(tok: string)
		-expectKeyword(keyword: string)
		-parsePackageId(): string
		-parsePackageName(): string
		-parseDotIdent(): string
		-parseQualifiedName(): (id: string, name: string)
		-getPkg(id: string, name: string): types.Package
		-parseExportedName(): (pkg: types.Package, name: string)
		-parseBasicType(): types.Type
		-parseArrayType(parent: types.Package): types.Type
		-parseMapType(parent: types.Package): types.Type
		-parseName(parent: types.Package, materializePkg: bool): (pkg: types.Package, name: string)
		-parseField(parent: types.Package): (types.Var, string)
		-parseStructType(parent: types.Package): types.Type
		-parseParameter(): (par: types.Var, isVariadic: bool)
		-parseParameters(): (list: types.Var, isVariadic: bool)
		-parseSignature(recv: types.Var): types.Signature
		-parseInterfaceType(parent: types.Package): types.Type
		-parseChanType(parent: types.Package): types.Type
		-parseType(parent: types.Package): types.Type
		-parseImportDecl()
		-parseInt(): string
		-parseNumber(): (typ: types.Basic, val: constant.Value)
		-parseConstDecl()
		-parseTypeDecl()
		-parseVarDecl()
		-parseFunc(recv: types.Var): types.Signature
		-parseMethodDecl()
		-parseFuncDecl()
		-parseDecl()
		-parseExport(): types.Package
	}
}



package "pkg" {
	class "SomeType" as pkg.SomeType <<V,Orchid>> {
		+X: float64
		+AMethod(x: int): int
		+AnotherMethod(x: int): int
	}
}



package "linutil" {
	class "AMD64PtraceRegs" as linutil.AMD64PtraceRegs <<V,Orchid>> {
		+R15: uint64
		+R14: uint64
		+R13: uint64
		...
	}
}



package "linutil" {
	class "AMD64Registers" as linutil.AMD64Registers <<V,Orchid>> {
		+Regs: *linutil.AMD64PtraceRegs
		+Fpregs: proc.Register
		+Fpregset: amd64util.AMD64Xstate
		-loadFpRegs: func(*linutil.AMD64Registers) error
		+Slice(floatingPoint: bool): (proc.Register, error)
		+PC(): uint64
		+SP(): uint64
		+BP(): uint64
		+TLS(): uint64
		+GAddr(): (uint64, bool)
		+Get(n: int): (uint64, error)
		+Copy(): (proc.Registers, error)
	}
}

	linutil.AMD64Registers --> linutil.AMD64PtraceRegs
	linutil.AMD64Registers --> proc.Register
	linutil.AMD64Registers --> amd64util.AMD64Xstate

package "linutil" {
	class "linkMap" as linutil.linkMap <<V,Orchid>> {
		-addr: uint64
		-name: string
		-ld: uint64
		-next: uint64
		-prev: uint64
	}
}


package "test" {
	class "BuildFlags" as test.BuildFlags <<V,Orchid>>
}


package "test" {
	class "Fixture" as test.Fixture <<V,Orchid>> {
		+Name: string
		+Path: string
		+Source: string
		+BuildDir: string
	}
}



package "test" {
	class "fixtureKey" as test.fixtureKey <<V,Orchid>> {
		+Name: string
		+Flags: test.BuildFlags
	}
}

	test.fixtureKey --> test.BuildFlags


package "syntax" {
	class "AssignStmt" as syntax.AssignStmt <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+OpPos: syntax.Position
		+Op: syntax.Token
		+LHS: syntax.Expr
		+RHS: syntax.Expr
		-stmt()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.AssignStmt --> syntax.commentsRef
	syntax.AssignStmt --> syntax.Position
	syntax.AssignStmt --> syntax.Token
	syntax.AssignStmt --> syntax.Expr

package "syntax" {
	class "BinaryExpr" as syntax.BinaryExpr <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+X: syntax.Expr
		+OpPos: syntax.Position
		+Op: syntax.Token
		+Y: syntax.Expr
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.BinaryExpr --> syntax.commentsRef
	syntax.BinaryExpr --> syntax.Expr
	syntax.BinaryExpr --> syntax.Position
	syntax.BinaryExpr --> syntax.Token

package "syntax" {
	class "BranchStmt" as syntax.BranchStmt <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+Token: syntax.Token
		+TokenPos: syntax.Position
		-stmt()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.BranchStmt --> syntax.commentsRef
	syntax.BranchStmt --> syntax.Token
	syntax.BranchStmt --> syntax.Position

package "syntax" {
	class "CallExpr" as syntax.CallExpr <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+Fn: syntax.Expr
		+Lparen: syntax.Position
		+Args: []syntax.Expr
		+Rparen: syntax.Position
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.CallExpr --> syntax.commentsRef
	syntax.CallExpr --> syntax.Expr
	syntax.CallExpr --> syntax.Position

package "syntax" {
	class "Comment" as syntax.Comment <<V,Orchid>> {
		+Start: syntax.Position
		+Text: string
	}
}

	syntax.Comment --> syntax.Position


package "syntax" {
	class "Comments" as syntax.Comments <<V,Orchid>> {
		+Before: []syntax.Comment
		+Suffix: []syntax.Comment
		+After: []syntax.Comment
	}
}

	syntax.Comments --> syntax.Comment


package "syntax" {
	class "Comprehension" as syntax.Comprehension <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+Curly: bool
		+Lbrack: syntax.Position
		+Body: syntax.Expr
		+Clauses: []syntax.Node
		+Rbrack: syntax.Position
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.Comprehension --> syntax.commentsRef
	syntax.Comprehension --> syntax.Position
	syntax.Comprehension --> syntax.Expr
	syntax.Comprehension --> syntax.Node
	syntax.Comprehension --> syntax.Position


package "syntax" {
	class "CondExpr" as syntax.CondExpr <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+If: syntax.Position
		+Cond: syntax.Expr
		+True: syntax.Expr
		+ElsePos: syntax.Position
		+False: syntax.Expr
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.CondExpr --> syntax.commentsRef
	syntax.CondExpr --> syntax.Position
	syntax.CondExpr --> syntax.Expr


package "syntax" {
	class "DefStmt" as syntax.DefStmt <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+Def: syntax.Position
		+Name: *syntax.Ident
		+Params: []syntax.Expr
		+Body: []syntax.Stmt
		+Function: interface{}
		-stmt()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.DefStmt --> syntax.commentsRef
	syntax.DefStmt --> syntax.Position
	syntax.DefStmt --> syntax.Ident
	syntax.DefStmt --> syntax.Expr
	syntax.DefStmt --> syntax.Stmt

package "syntax" {
	class "DictEntry" as syntax.DictEntry <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+Key: syntax.Expr
		+Colon: syntax.Position
		+Value: syntax.Expr
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.DictEntry --> syntax.commentsRef
	syntax.DictEntry --> syntax.Expr
	syntax.DictEntry --> syntax.Position

package "syntax" {
	class "DictExpr" as syntax.DictExpr <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+Lbrace: syntax.Position
		+List: []syntax.Expr
		+Rbrace: syntax.Position
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.DictExpr --> syntax.commentsRef
	syntax.DictExpr --> syntax.Position
	syntax.DictExpr --> syntax.Expr


package "syntax" {
	class "DotExpr" as syntax.DotExpr <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+X: syntax.Expr
		+Dot: syntax.Position
		+NamePos: syntax.Position
		+Name: *syntax.Ident
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.DotExpr --> syntax.commentsRef
	syntax.DotExpr --> syntax.Expr
	syntax.DotExpr --> syntax.Position
	syntax.DotExpr --> syntax.Ident

package "syntax" {
	interface "Expr" as syntax.Expr {
		+AllocComments()
		+Comments(): *syntax.Comments
		+Span(): (start: syntax.Position, end: syntax.Position)
		-expr()
	}
}


	syntax.Expr ..> syntax.Comments : <<return>> 
	syntax.Expr ..> syntax.Position : <<return>>

package "syntax" {
	class "ExprStmt" as syntax.ExprStmt <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+X: syntax.Expr
		-stmt()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.ExprStmt --> syntax.commentsRef
	syntax.ExprStmt --> syntax.Expr
	syntax.ExprStmt ..> syntax.Position : <<return>>

package "syntax" {
	class "File" as syntax.File <<V,Orchid>> {
		-commentsRef: syntax.commentsRef
		+Path: string
		+Stmts: []syntax.Stmt
		+Module: interface{}
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.File --> syntax.commentsRef
	syntax.File --> syntax.Stmt
	syntax.File ..> syntax.Position : <<return>>

package "syntax" {
	class "ForClause" as syntax.ForClause <<V,Orchid>> {
		-commentsRef: syntax.commentsRef
		+For: syntax.Position
		+Vars: syntax.Expr
		+In: syntax.Position
		+X: syntax.Expr
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.ForClause --> syntax.commentsRef
	syntax.ForClause --> syntax.Position
	syntax.ForClause --> syntax.Expr

package "syntax" {
	class "ForStmt" as syntax.ForStmt <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+For: syntax.Position
		+Vars: syntax.Expr
		+X: syntax.Expr
		+Body: []syntax.Stmt
		-stmt()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.ForStmt --> syntax.commentsRef
	syntax.ForStmt --> syntax.Position
	syntax.ForStmt --> syntax.Expr
	syntax.ForStmt --> syntax.Stmt

package "syntax" {
	class "Ident" as syntax.Ident <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+NamePos: syntax.Position
		+Name: string
		+Binding: interface{}
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.Ident --> syntax.commentsRef
	syntax.Ident --> syntax.Position

package "syntax" {
	class "IfClause" as syntax.IfClause <<V,Orchid>> {
		-commentsRef: syntax.commentsRef
		+If: syntax.Position
		+Cond: syntax.Expr
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.IfClause --> syntax.commentsRef
	syntax.IfClause --> syntax.Position
	syntax.IfClause --> syntax.Expr

package "syntax" {
	class "IfStmt" as syntax.IfStmt <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+If: syntax.Position
		+Cond: syntax.Expr
		+True: []syntax.Stmt
		+ElsePos: syntax.Position
		+False: []syntax.Stmt
		-stmt()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.IfStmt --> syntax.commentsRef
	syntax.IfStmt --> syntax.Position
	syntax.IfStmt --> syntax.Expr
	syntax.IfStmt --> syntax.Stmt

package "syntax" {
	class "IndexExpr" as syntax.IndexExpr <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+X: syntax.Expr
		+Lbrack: syntax.Position
		+Y: syntax.Expr
		+Rbrack: syntax.Position
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.IndexExpr --> syntax.commentsRef
	syntax.IndexExpr --> syntax.Expr
	syntax.IndexExpr --> syntax.Position

package "syntax" {
	class "LambdaExpr" as syntax.LambdaExpr <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+Lambda: syntax.Position
		+Params: []syntax.Expr
		+Body: syntax.Expr
		+Function: interface{}
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.LambdaExpr --> syntax.commentsRef
	syntax.LambdaExpr --> syntax.Position
	syntax.LambdaExpr --> syntax.Expr

package "syntax" {
	class "ListExpr" as syntax.ListExpr <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+Lbrack: syntax.Position
		+List: []syntax.Expr
		+Rbrack: syntax.Position
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.ListExpr --> syntax.commentsRef
	syntax.ListExpr --> syntax.Position
	syntax.ListExpr --> syntax.Expr


package "syntax" {
	class "Literal" as syntax.Literal <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+Token: syntax.Token
		+TokenPos: syntax.Position
		+Raw: string
		+Value: interface{}
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.Literal --> syntax.commentsRef
	syntax.Literal --> syntax.Token
	syntax.Literal --> syntax.Position


package "syntax" {
	class "LoadStmt" as syntax.LoadStmt <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+Load: syntax.Position
		+Module: *syntax.Literal
		+From: []*syntax.Ident
		+To: []*syntax.Ident
		+Rparen: syntax.Position
		-stmt()
		+Span(): (start: syntax.Position, end: syntax.Position)
		+ModuleName(): string
	}
}

	syntax.LoadStmt --> syntax.commentsRef
	syntax.LoadStmt --> syntax.Position
	syntax.LoadStmt --> syntax.Literal


package "syntax" {
	class "Mode" as syntax.Mode <<V,Orchid>>
}



package "syntax" {
	interface "Node" as syntax.Node {
		+AllocComments()
		+Comments(): *syntax.Comments
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}


	syntax.Node ..> syntax.Comments : <<return>> 
	syntax.Node ..> syntax.Position : <<return>>

package "syntax" {
	class "ParenExpr" as syntax.ParenExpr <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+Lparen: syntax.Position
		+X: syntax.Expr
		+Rparen: syntax.Position
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.ParenExpr --> syntax.commentsRef
	syntax.ParenExpr --> syntax.Position
	syntax.ParenExpr --> syntax.Expr

package "syntax" {
	class "Position" as syntax.Position <<V,Orchid>> {
		-file: *string
		+Line: int32
		+Col: int32
		+IsValid(): bool
		+Filename(): string
		-add(s: string): syntax.Position
		+String(): string
		-isBefore(q: syntax.Position): bool
	}
}



package "syntax" {
	class "ReturnStmt" as syntax.ReturnStmt <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+Return: syntax.Position
		+Result: syntax.Expr
		-stmt()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.ReturnStmt --> syntax.commentsRef
	syntax.ReturnStmt --> syntax.Position
	syntax.ReturnStmt --> syntax.Expr

package "syntax" {
	class "SliceExpr" as syntax.SliceExpr <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+X: syntax.Expr
		+Lbrack: syntax.Position
		+Lo: syntax.Expr
		+Hi: syntax.Expr
		+Step: syntax.Expr
		+Rbrack: syntax.Position
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.SliceExpr --> syntax.commentsRef
	syntax.SliceExpr --> syntax.Expr
	syntax.SliceExpr --> syntax.Position

package "syntax" {
	interface "Stmt" as syntax.Stmt {
		+AllocComments()
		+Comments(): *syntax.Comments
		+Span(): (start: syntax.Position, end: syntax.Position)
		-stmt()
	}
}


	syntax.Stmt ..> syntax.Comments : <<return>> 
	syntax.Stmt ..> syntax.Position : <<return>>

package "syntax" {
	class "Token" as syntax.Token <<V,Orchid>> {
		+String(): string
		+GoString(): string
	}
}



package "syntax" {
	class "TupleExpr" as syntax.TupleExpr <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+Lparen: syntax.Position
		+List: []syntax.Expr
		+Rparen: syntax.Position
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.TupleExpr --> syntax.commentsRef
	syntax.TupleExpr --> syntax.Position
	syntax.TupleExpr --> syntax.Expr

package "syntax" {
	class "UnaryExpr" as syntax.UnaryExpr <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+OpPos: syntax.Position
		+Op: syntax.Token
		+X: syntax.Expr
		-expr()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.UnaryExpr --> syntax.commentsRef
	syntax.UnaryExpr --> syntax.Position
	syntax.UnaryExpr --> syntax.Token
	syntax.UnaryExpr --> syntax.Expr

package "syntax" {
	class "WhileStmt" as syntax.WhileStmt <<E,#FFCC00>> {
		-commentsRef: syntax.commentsRef
		+While: syntax.Position
		+Cond: syntax.Expr
		+Body: []syntax.Stmt
		-stmt()
		+Span(): (start: syntax.Position, end: syntax.Position)
	}
}

	syntax.WhileStmt --> syntax.commentsRef
	syntax.WhileStmt --> syntax.Position
	syntax.WhileStmt --> syntax.Expr
	syntax.WhileStmt --> syntax.Stmt

package "syntax" {
	class "commentsRef" as syntax.commentsRef <<E,#FFCC00>> {
		-ref: *syntax.Comments
		+Comments(): *syntax.Comments
		+AllocComments()
	}
}

	syntax.commentsRef --> syntax.Comments
	syntax.commentsRef ..> syntax.Comments : <<return>>

package "syntax" {
	class "parser" as syntax.parser <<E,#FFCC00>> {
		-in: *syntax.scanner
		-tok: syntax.Token
		-tokval: syntax.tokenValue
		-nextToken(): syntax.Position
		-parseFile(): *syntax.File
		-parseStmt(stmts: []syntax.Stmt): []syntax.Stmt
		-parseDefStmt(): syntax.Stmt
		-parseIfStmt(): syntax.Stmt
		-parseForStmt(): syntax.Stmt
		-parseWhileStmt(): syntax.Stmt
		-parseForLoopVariables(): syntax.Expr
		-parseSimpleStmt(stmts: []syntax.Stmt, consumeNL: bool): []syntax.Stmt
		-parseSmallStmt(): syntax.Stmt
		-parseLoadStmt(): *syntax.LoadStmt
		-parseSuite(): []syntax.Stmt
		-parseIdent(): *syntax.Ident
		-consume(t: syntax.Token): syntax.Position
		-parseParams(): []syntax.Expr
		-parseExpr(inParens: bool): syntax.Expr
		-parseExprs(exprs: []syntax.Expr, allowTrailingComma: bool): []syntax.Expr
		-parseTest(): syntax.Expr
		-parseTestNoCond(): syntax.Expr
		-parseLambda(allowCond: bool): syntax.Expr
		-parseTestPrec(prec: int): syntax.Expr
		-parseBinopExpr(prec: int): syntax.Expr
		-parsePrimaryWithSuffix(): syntax.Expr
		-parseSliceSuffix(x: syntax.Expr): syntax.Expr
		-parseCallSuffix(fn: syntax.Expr): syntax.Expr
		-parseArgs(): []syntax.Expr
		-parsePrimary(): syntax.Expr
		-parseList(): syntax.Expr
		-parseDict(): syntax.Expr
		-parseDictEntry(): *syntax.DictEntry
		-parseComprehensionSuffix(lbrace: syntax.Position, body: syntax.Expr, endBrace: syntax.Token): syntax.Expr
		-assignComments(n: syntax.Node)
	}
}

	syntax.parser --> syntax.scanner
	syntax.parser --> syntax.Token
	syntax.parser --> syntax.tokenValue


package "syntax" {
	class "scanner" as syntax.scanner <<E,#FFCC00>> {
		-rest: []byte
		-token: []byte
		-pos: syntax.Position
		-depth: int
		-indentstk: []int
		-dents: int
		-lineStart: bool
		-keepComments: bool
		-lineComments: []syntax.Comment
		-suffixComments: []syntax.Comment
		-readline: func() ([]byte, error)
		-error(pos: syntax.Position, s: string)
		-errorf(pos: syntax.Position, format: string, args: []interface{})
		-recover(err: *error)
		-eof(): bool
		-readLine(): bool
		-peekRune(): rune
		-readRune(): rune
		-startToken(val: *syntax.tokenValue)
		-endToken(val: *syntax.tokenValue)
		-nextToken(val: *syntax.tokenValue): syntax.Token
		-scanString(val: *syntax.tokenValue, quote: rune): syntax.Token
		-scanNumber(val: *syntax.tokenValue, c: rune): syntax.Token
	}
}

	syntax.scanner --> syntax.Position
	syntax.scanner --> syntax.Comment


package "syntax" {
	class "tokenValue" as syntax.tokenValue <<V,Orchid>> {
		-raw: string
		-int: int64
		-bigInt: big.Int
		-float: float64
		-string: string
		-pos: syntax.Position
	}
}

	syntax.tokenValue --> syntax.Position


package "span" {
	interface "Converter" as span.Converter {
		+ToOffset(line: int, col: int): (int, error)
		+ToPosition(offset: int): (int, int, error)
	}
}


package "span" {
	class "Point" as span.Point <<E,#FFCC00>> {
		-v: span.point
		+HasPosition(): bool
		+HasOffset(): bool
		+IsValid(): bool
		+MarshalJSON(): ([]byte, error)
		+UnmarshalJSON(b: []byte): error
		+Line(): int
		+Column(): int
		+Offset(): int
	}
}

	span.Point --> span.point


package "span" {
	class "Range" as span.Range <<V,Orchid>> {
		+FileSet: token.FileSet
		+Start: token.Pos
		+End: token.Pos
		+Converter: span.Converter
		+IsPoint(): bool
		+Span(): (span.Span, error)
	}
}

	span.Range --> span.Converter
	span.Range ..> span.Span : <<return>>

package "span" {
	class "Span" as span.Span <<E,#FFCC00>> {
		-v: span.span
		+HasPosition(): bool
		+HasOffset(): bool
		+IsValid(): bool
		+IsPoint(): bool
		+URI(): span.URI
		+Start(): span.Point
		+End(): span.Point
		+MarshalJSON(): ([]byte, error)
		+UnmarshalJSON(b: []byte): error
		+Format(f: fmt.State, c: rune)
		+WithPosition(c: span.Converter): (span.Span, error)
		+WithOffset(c: span.Converter): (span.Span, error)
		+WithAll(c: span.Converter): (span.Span, error)
		-update(c: span.Converter, withPos: bool, withOffset: bool): error
		+Range(converter: *span.TokenConverter): (span.Range, error)
	}
}

	span.Span --> span.span

	span.Span ..> span.URI : <<return>> 
	span.Span ..> span.Point : <<return>> 
	span.Span ..> span.Converter : <<use>>
	span.Span ..> span.Span : <<return>> 
	span.Span ..> span.TokenConverter : <<use>>
	span.Span ..> span.Range : <<return>> 

package "span" {
	class "TokenConverter" as span.TokenConverter <<V,Orchid>> {
		-fset: token.FileSet
		-file: token.File
		+ToPosition(offset: int): (int, int, error)
		+ToOffset(line: int, col: int): (int, error)
	}
}


package "span" {
	class "URI" as span.URI <<V,Orchid>> {
		+Filename(): string
	}
}


package "span" {
	class "point" as span.point <<E,#FFCC00>> {
		+Line: int
		+Column: int
		+Offset: int
		-hasPosition(): bool
		-hasOffset(): bool
		-isValid(): bool
		-isZero(): bool
		-clean()
		-updatePosition(c: span.Converter): error
		-updateOffset(c: span.Converter): error
	}
}



package "span" {
	class "span" as span.span <<E,#FFCC00>> {
		+URI: span.URI
		+Start: span.point
		+End: span.point
		-clean()
	}
}

	span.span --> span.URI
	span.span --> span.point


package "span" {
	class "suffix" as span.suffix <<V,Orchid>> {
		-remains: string
		-sep: string
		-num: int
	}
}


package "op" {
	class "DwarfRegister" as op.DwarfRegister <<V,Orchid>> {
		+Uint64Val: uint64
		+Bytes: []byte
	}
}

package "op" {
	class "DwarfRegisters" as op.DwarfRegisters <<E,#FFCC00>> {
		+StaticBase: uint64
		+CFA: int64
		+FrameBase: int64
		+ObjBase: int64
		-regs: []*op.DwarfRegister
		+ByteOrder: binary.ByteOrder
		+PCRegNum: uint64
		+SPRegNum: uint64
		+BPRegNum: uint64
		+LRRegNum: uint64
		+FloatLoadError: error
		-loadMoreCallback: func()
		+SetLoadMoreCallback(fn: func())
		+CurrentSize(): int
		+Uint64Val(idx: uint64): uint64
		+Bytes(idx: uint64): []byte
		-loadMore()
		+Reg(idx: uint64): *op.DwarfRegister
		+PC(): uint64
		+SP(): uint64
		+BP(): uint64
		+AddReg(idx: uint64, reg: *op.DwarfRegister)
		+ClearRegisters()
	}
}

	op.DwarfRegisters ..> op.DwarfRegister

package "op" {
	class "Opcode" as op.Opcode <<V,Orchid>>
}


package "op" {
	class "Piece" as op.Piece <<V,Orchid>> {
		+Size: int
		+Addr: int64
		+RegNum: uint64
		+IsRegister: bool
	}
}


package "op" {
	class "context" as op.context <<V,Orchid>> {
		-buf: *bytes.Buffer
		-stack: []int64
		-pieces: []op.Piece
		-reg: bool
		-ptrSize: int
		+DwarfRegisters: op.DwarfRegisters
	}
}

	op.context --> op.Piece
	op.context --> op.DwarfRegisters


package "op" {
	class "stackfn" as op.stackfn <<V,Orchid>> {
		-stackfn(: op.Opcode, : *op.context): error
	}
}


package "fastwalk" {
	class "walkItem" as fastwalk.walkItem <<V,Orchid>> {
		-dir: string
		-callbackDone: bool
	}
}


package "fastwalk" {
	class "walker" as fastwalk.walker <<E,#FFCC00>> {
		-fn: func(path string, typ os.FileMode) error
		-donec: chan struct{}
		-workc: chan fastwalk.walkItem
		-enqueuec: chan fastwalk.walkItem
		-resc: chan error
		-doWork(wg: *sync.WaitGroup)
		-enqueue(it: fastwalk.walkItem)
		-onDirEnt(dirName: string, baseName: string, typ: os.FileMode): error
		-walk(root: string, runUserCallback: bool): error
	}
}


package "amd64util" {
	class "AMD64PtraceFpRegs" as amd64util.AMD64PtraceFpRegs <<V,Orchid>> {
		+Cwd: uint16
		+Swd: uint16
		+Ftw: uint16
		+Fop: uint16
		+Rip: uint64
		+Rdp: uint64
		+Mxcsr: uint32
		+MxcrMask: uint32
		+StSpace: [32]uint32
		+XmmSpace: [256]byte
		+Padding: [24]uint32
	}
}



package "amd64util" {
	class "AMD64Xstate" as amd64util.AMD64Xstate <<V,Orchid>> {
		+AMD64PtraceFpRegs: amd64util.AMD64PtraceFpRegs
		+Xsave: []byte
		+AvxState: bool
		+YmmSpace: [256]byte
		+Avx512State: bool
		+ZmmSpace: [512]byte
		+Decode(): proc.Register
	}
}

	amd64util.AMD64Xstate --> amd64util.AMD64PtraceFpRegs
	amd64util.AMD64Xstate ..> proc.Register : <<return>>


package "rpc2" {
	class "AmendBreakpointIn" as rpc2.AmendBreakpointIn <<V,Orchid>> {
		+Breakpoint: api.Breakpoint
	}
}

	rpc2.AmendBreakpointIn --> api.Breakpoint


package "rpc2" {
	class "AmendBreakpointOut" as rpc2.AmendBreakpointOut <<V,Orchid>>
}


package "rpc2" {
	class "AncestorsIn" as rpc2.AncestorsIn <<V,Orchid>> {
		+GoroutineID: int
		+NumAncestors: int
		+Depth: int
	}
}



package "rpc2" {
	class "AncestorsOut" as rpc2.AncestorsOut <<V,Orchid>> {
		+Ancestors: api.Ancestor
	}
}

	rpc2.AncestorsOut --> api.Ancestor


package "rpc2" {
	class "AttachedToExistingProcessIn" as rpc2.AttachedToExistingProcessIn <<V,Orchid>>
}



package "rpc2" {
	class "AttachedToExistingProcessOut" as rpc2.AttachedToExistingProcessOut <<V,Orchid>> {
		+Answer: bool
	}
}



package "rpc2" {
	class "CancelNextIn" as rpc2.CancelNextIn <<V,Orchid>>
}



package "rpc2" {
	class "CancelNextOut" as rpc2.CancelNextOut <<V,Orchid>>
}



package "rpc2" {
	class "CheckpointIn" as rpc2.CheckpointIn <<V,Orchid>> {
		+Where: string
	}
}



package "rpc2" {
	class "CheckpointOut" as rpc2.CheckpointOut <<V,Orchid>> {
		+ID: int
	}
}



package "rpc2" {
	class "ClearBreakpointIn" as rpc2.ClearBreakpointIn <<V,Orchid>> {
		+Id: int
		+Name: string
	}
}



package "rpc2" {
	class "ClearBreakpointOut" as rpc2.ClearBreakpointOut <<V,Orchid>> {
		+Breakpoint: api.Breakpoint
	}
}

	rpc2.ClearBreakpointOut --> api.Breakpoint


package "rpc2" {
	class "ClearCheckpointIn" as rpc2.ClearCheckpointIn <<V,Orchid>> {
		+ID: int
	}
}



package "rpc2" {
	class "ClearCheckpointOut" as rpc2.ClearCheckpointOut <<V,Orchid>>
}



package "rpc2" {
	class "CommandOut" as rpc2.CommandOut <<V,Orchid>> {
		+State: api.DebuggerState
	}
}

	rpc2.CommandOut --> api.DebuggerState


package "rpc2" {
	class "CreateBreakpointIn" as rpc2.CreateBreakpointIn <<V,Orchid>> {
		+Breakpoint: api.Breakpoint
	}
}

	rpc2.CreateBreakpointIn --> api.Breakpoint


package "rpc2" {
	class "CreateBreakpointOut" as rpc2.CreateBreakpointOut <<V,Orchid>> {
		+Breakpoint: api.Breakpoint
	}
}

	rpc2.CreateBreakpointOut --> api.Breakpoint


package "rpc2" {
	class "DetachIn" as rpc2.DetachIn <<V,Orchid>> {
		+Kill: bool
	}
}



package "rpc2" {
	class "DetachOut" as rpc2.DetachOut <<V,Orchid>>
}



package "rpc2" {
	class "DisassembleIn" as rpc2.DisassembleIn <<V,Orchid>> {
		+Scope: api.EvalScope
		+StartPC: uint64
		+EndPC: uint64
		+Flavour: api.AssemblyFlavour
	}
}

	rpc2.DisassembleIn --> api.EvalScope
	rpc2.DisassembleIn --> api.AssemblyFlavour


package "rpc2" {
	class "DisassembleOut" as rpc2.DisassembleOut <<V,Orchid>> {
		+Disassemble: api.AsmInstructions
	}
}

	rpc2.DisassembleOut --> api.AsmInstructions


package "rpc2" {
	class "EvalIn" as rpc2.EvalIn <<V,Orchid>> {
		+Scope: api.EvalScope
		+Expr: string
		+Cfg: api.LoadConfig
	}
}

	rpc2.EvalIn --> api.EvalScope
	rpc2.EvalIn --> api.LoadConfig


package "rpc2" {
	class "EvalOut" as rpc2.EvalOut <<V,Orchid>> {
		+Variable: api.Variable
	}
}

	rpc2.EvalOut --> api.Variable


package "rpc2" {
	class "ExamineMemoryIn" as rpc2.ExamineMemoryIn <<V,Orchid>> {
		+Address: uint64
		+Length: int
	}
}



package "rpc2" {
	class "ExaminedMemoryOut" as rpc2.ExaminedMemoryOut <<V,Orchid>> {
		+Mem: []byte
		+IsLittleEndian: bool
	}
}



package "rpc2" {
	class "FindLocationIn" as rpc2.FindLocationIn <<V,Orchid>> {
		+Scope: api.EvalScope
		+Loc: string
		+IncludeNonExecutableLines: bool
		+SubstitutePathRules: [][2]string
	}
}

	rpc2.FindLocationIn --> api.EvalScope


package "rpc2" {
	class "FindLocationOut" as rpc2.FindLocationOut <<V,Orchid>> {
		+Locations: api.Location
	}
}

	rpc2.FindLocationOut --> api.Location


package "rpc2" {
	class "FunctionReturnLocationsIn" as rpc2.FunctionReturnLocationsIn <<V,Orchid>> {
		+FnName: string
	}
}



package "rpc2" {
	class "FunctionReturnLocationsOut" as rpc2.FunctionReturnLocationsOut <<V,Orchid>> {
		+Addrs: []uint64
	}
}



package "rpc2" {
	class "GetBreakpointIn" as rpc2.GetBreakpointIn <<V,Orchid>> {
		+Id: int
		+Name: string
	}
}



package "rpc2" {
	class "GetBreakpointOut" as rpc2.GetBreakpointOut <<V,Orchid>> {
		+Breakpoint: api.Breakpoint
	}
}

	rpc2.GetBreakpointOut --> api.Breakpoint


package "rpc2" {
	class "GetThreadIn" as rpc2.GetThreadIn <<V,Orchid>> {
		+Id: int
	}
}



package "rpc2" {
	class "GetThreadOut" as rpc2.GetThreadOut <<V,Orchid>> {
		+Thread: api.Thread
	}
}

	rpc2.GetThreadOut --> api.Thread


package "rpc2" {
	class "IsMulticlientIn" as rpc2.IsMulticlientIn <<V,Orchid>>
}



package "rpc2" {
	class "IsMulticlientOut" as rpc2.IsMulticlientOut <<V,Orchid>> {
		+IsMulticlient: bool
	}
}



package "rpc2" {
	class "LastModifiedIn" as rpc2.LastModifiedIn <<V,Orchid>>
}



package "rpc2" {
	class "LastModifiedOut" as rpc2.LastModifiedOut <<V,Orchid>> {
		+Time: time.Time
	}
}

	rpc2.LastModifiedOut --> time.Time


package "rpc2" {
	class "ListBreakpointsIn" as rpc2.ListBreakpointsIn <<V,Orchid>>
}



package "rpc2" {
	class "ListBreakpointsOut" as rpc2.ListBreakpointsOut <<V,Orchid>> {
		+Breakpoints: api.Breakpoint
	}
}



package "rpc2" {
	class "ListCheckpointsIn" as rpc2.ListCheckpointsIn <<V,Orchid>>
}



package "rpc2" {
	class "ListCheckpointsOut" as rpc2.ListCheckpointsOut <<V,Orchid>> {
		+Checkpoints: api.Checkpoint
	}
}

	rpc2.ListCheckpointsOut --> api.Checkpoint


package "rpc2" {
	class "ListDynamicLibrariesIn" as rpc2.ListDynamicLibrariesIn <<V,Orchid>>
}



package "rpc2" {
	class "ListDynamicLibrariesOut" as rpc2.ListDynamicLibrariesOut <<V,Orchid>> {
		+List: api.Image
	}
}

	rpc2.ListDynamicLibrariesOut --> api.Image


package "rpc2" {
	class "ListFunctionArgsIn" as rpc2.ListFunctionArgsIn <<V,Orchid>> {
		+Scope: api.EvalScope
		+Cfg: api.LoadConfig
	}
}

	rpc2.ListFunctionArgsIn --> api.EvalScope
	rpc2.ListFunctionArgsIn --> api.LoadConfig


package "rpc2" {
	class "ListFunctionArgsOut" as rpc2.ListFunctionArgsOut <<V,Orchid>> {
		+Args: api.Variable
	}
}

	rpc2.ListFunctionArgsOut --> api.Variable


package "rpc2" {
	class "ListFunctionsIn" as rpc2.ListFunctionsIn <<V,Orchid>> {
		+Filter: string
	}
}



package "rpc2" {
	class "ListFunctionsOut" as rpc2.ListFunctionsOut <<V,Orchid>> {
		+Funcs: []string
	}
}



package "rpc2" {
	class "ListGoroutinesIn" as rpc2.ListGoroutinesIn <<V,Orchid>> {
		+Start: int
		+Count: int
	}
}



package "rpc2" {
	class "ListGoroutinesOut" as rpc2.ListGoroutinesOut <<V,Orchid>> {
		+Goroutines: api.Goroutine
		+Nextg: int
	}
}



package "rpc2" {
	class "ListLocalVarsIn" as rpc2.ListLocalVarsIn <<V,Orchid>> {
		+Scope: api.EvalScope
		+Cfg: api.LoadConfig
	}
}

	rpc2.ListLocalVarsIn --> api.EvalScope
	rpc2.ListLocalVarsIn --> api.LoadConfig


package "rpc2" {
	class "ListLocalVarsOut" as rpc2.ListLocalVarsOut <<V,Orchid>> {
		+Variables: api.Variable
	}
}

	rpc2.ListLocalVarsOut --> api.Variable


package "rpc2" {
	class "ListPackageVarsIn" as rpc2.ListPackageVarsIn <<V,Orchid>> {
		+Filter: string
		+Cfg: api.LoadConfig
	}
}

	rpc2.ListPackageVarsIn --> api.LoadConfig


package "rpc2" {
	class "ListPackageVarsOut" as rpc2.ListPackageVarsOut <<V,Orchid>> {
		+Variables: api.Variable
	}
}

	rpc2.ListPackageVarsOut --> api.Variable


package "rpc2" {
	class "ListPackagesBuildInfoIn" as rpc2.ListPackagesBuildInfoIn <<V,Orchid>> {
		+IncludeFiles: bool
	}
}



package "rpc2" {
	class "ListPackagesBuildInfoOut" as rpc2.ListPackagesBuildInfoOut <<V,Orchid>> {
		+List: api.PackageBuildInfo
	}
}

	rpc2.ListPackagesBuildInfoOut --> api.PackageBuildInfo


package "rpc2" {
	class "ListRegistersIn" as rpc2.ListRegistersIn <<V,Orchid>> {
		+ThreadID: int
		+IncludeFp: bool
		+Scope: api.EvalScope
	}
}

	rpc2.ListRegistersIn --> api.EvalScope


package "rpc2" {
	class "ListRegistersOut" as rpc2.ListRegistersOut <<V,Orchid>> {
		+Registers: string
		+Regs: api.Registers
	}
}

	rpc2.ListRegistersOut --> api.Registers


package "rpc2" {
	class "ListSourcesIn" as rpc2.ListSourcesIn <<V,Orchid>> {
		+Filter: string
	}
}



package "rpc2" {
	class "ListSourcesOut" as rpc2.ListSourcesOut <<V,Orchid>> {
		+Sources: []string
	}
}



package "rpc2" {
	class "ListThreadsIn" as rpc2.ListThreadsIn <<V,Orchid>>
}



package "rpc2" {
	class "ListThreadsOut" as rpc2.ListThreadsOut <<V,Orchid>> {
		+Threads: api.Thread
	}
}



package "rpc2" {
	class "ListTypesIn" as rpc2.ListTypesIn <<V,Orchid>> {
		+Filter: string
	}
}



package "rpc2" {
	class "ListTypesOut" as rpc2.ListTypesOut <<V,Orchid>> {
		+Types: []string
	}
}



package "rpc2" {
	class "ProcessPidIn" as rpc2.ProcessPidIn <<V,Orchid>>
}



package "rpc2" {
	class "ProcessPidOut" as rpc2.ProcessPidOut <<V,Orchid>> {
		+Pid: int
	}
}



package "rpc2" {
	class "RPCClient" as rpc2.RPCClient <<E,#FFCC00>> {
		-client: rpc.Client
		-retValLoadCfg: api.LoadConfig
		+ProcessPid(): int
		+LastModified(): time.Time
		+Detach(kill: bool): error
		+Restart(rebuild: bool): (api.DiscardedBreakpoint, error)
		+RestartFrom(rerecord: bool, pos: string, resetArgs: bool, newArgs: []string, newRedirects: [3]string, rebuild: bool): (api.DiscardedBreakpoint, error)
		+GetState(): (api.DebuggerState, error)
		+GetStateNonBlocking(): (api.DebuggerState, error)
		+Continue(): api.DebuggerState
		+Rewind(): api.DebuggerState
		+DirectionCongruentContinue(): api.DebuggerState
		-continueDir(cmd: string): api.DebuggerState
		+Next(): (api.DebuggerState, error)
		+ReverseNext(): (api.DebuggerState, error)
		+Step(): (api.DebuggerState, error)
		+ReverseStep(): (api.DebuggerState, error)
		+StepOut(): (api.DebuggerState, error)
		+ReverseStepOut(): (api.DebuggerState, error)
		+Call(goroutineID: int, expr: string, unsafe: bool): (api.DebuggerState, error)
		+StepInstruction(): (api.DebuggerState, error)
		+ReverseStepInstruction(): (api.DebuggerState, error)
		+SwitchThread(threadID: int): (api.DebuggerState, error)
		+SwitchGoroutine(goroutineID: int): (api.DebuggerState, error)
		+Halt(): (api.DebuggerState, error)
		+GetBreakpoint(id: int): (api.Breakpoint, error)
		+GetBreakpointByName(name: string): (api.Breakpoint, error)
		+CreateBreakpoint(breakPoint: api.Breakpoint): (api.Breakpoint, error)
		+ListBreakpoints(): (api.Breakpoint, error)
		+ClearBreakpoint(id: int): (api.Breakpoint, error)
		+ClearBreakpointByName(name: string): (api.Breakpoint, error)
		+AmendBreakpoint(bp: api.Breakpoint): error
		+CancelNext(): error
		+ListThreads(): (api.Thread, error)
		+GetThread(id: int): (api.Thread, error)
		+EvalVariable(scope: api.EvalScope, expr: string, cfg: api.LoadConfig): (api.Variable, error)
		+SetVariable(scope: api.EvalScope, symbol: string, value: string): error
		+ListSources(filter: string): ([]string, error)
		+ListFunctions(filter: string): ([]string, error)
		+ListTypes(filter: string): ([]string, error)
		+ListPackageVariables(filter: string, cfg: api.LoadConfig): (api.Variable, error)
		+ListLocalVariables(scope: api.EvalScope, cfg: api.LoadConfig): (api.Variable, error)
		+ListThreadRegisters(threadID: int, includeFp: bool): (api.Registers, error)
		+ListScopeRegisters(scope: api.EvalScope, includeFp: bool): (api.Registers, error)
		+ListFunctionArgs(scope: api.EvalScope, cfg: api.LoadConfig): (api.Variable, error)
		+ListGoroutines(start: int, count: int): (api.Goroutine, int, error)
		+Stacktrace(goroutineId: int, depth: int, opts: api.StacktraceOptions, cfg: api.LoadConfig): (api.Stackframe, error)
		+Ancestors(goroutineID: int, numAncestors: int, depth: int): (api.Ancestor, error)
		+AttachedToExistingProcess(): bool
		+FindLocation(scope: api.EvalScope, loc: string, findInstructions: bool, substitutePathRules: [][2]string): (api.Location, error)
		+DisassembleRange(scope: api.EvalScope, startPC: uint64, endPC: uint64, flavour: api.AssemblyFlavour): (api.AsmInstructions, error)
		+DisassemblePC(scope: api.EvalScope, pc: uint64, flavour: api.AssemblyFlavour): (api.AsmInstructions, error)
		+Recorded(): bool
		+TraceDirectory(): (string, error)
		+Checkpoint(where: string): (checkpointID: int, err: error)
		+ListCheckpoints(): (api.Checkpoint, error)
		+ClearCheckpoint(id: int): error
		+SetReturnValuesLoadConfig(cfg: api.LoadConfig)
		+FunctionReturnLocations(fnName: string): ([]uint64, error)
		+IsMulticlient(): bool
		+Disconnect(cont: bool): error
		+ListDynamicLibraries(): (api.Image, error)
		+ExamineMemory(address: uint64, count: int): ([]byte, bool, error)
		+StopRecording(): error
		-call(method: string, args: interface{}, reply: interface{}): error
		+CallAPI(method: string, args: interface{}, reply: interface{}): error
	}
}

	rpc2.RPCClient ..> api.LoadConfig

	rpc2.RPCClient ..> api.Ancestor : <<return>>
	rpc2.RPCClient ..> api.AsmInstructions : <<return>>
	rpc2.RPCClient ..> api.AssemblyFlavour : <<use>>
	rpc2.RPCClient ..> api.Breakpoint : <<return>>
	rpc2.RPCClient ..> api.Breakpoint : <<use>>
	rpc2.RPCClient ..> api.Checkpoint : <<return>>
	rpc2.RPCClient ..> api.DebuggerState : <<return>>
	rpc2.RPCClient ..> api.DiscardedBreakpoint : <<return>>
	rpc2.RPCClient ..> api.EvalScope : <<use>>
	rpc2.RPCClient ..> api.Image : <<return>>
	rpc2.RPCClient ..> api.Location : <<return>>
	rpc2.RPCClient ..> api.Registers : <<return>>
	rpc2.RPCClient ..> api.Stackframe : <<return>>
	rpc2.RPCClient ..> api.StacktraceOptions : <<use>>
	rpc2.RPCClient ..> api.Thread : <<return>>
	rpc2.RPCClient ..> api.Variable : <<return>>
	rpc2.RPCClient ..> time.Time : <<return>>


package "rpc2" {
	class "RPCServer" as rpc2.RPCServer <<E,#FFCC00>> {
		-config: service.Config
		-debugger: debugger.Debugger
		+ProcessPid(arg: rpc2.ProcessPidIn, out: *rpc2.ProcessPidOut): error
		+LastModified(arg: rpc2.LastModifiedIn, out: *rpc2.LastModifiedOut): error
		+Detach(arg: rpc2.DetachIn, out: *rpc2.DetachOut): error
		+Restart(arg: rpc2.RestartIn, cb: service.RPCCallback)
		+State(arg: rpc2.StateIn, cb: service.RPCCallback)
		+Command(command: api.DebuggerCommand, cb: service.RPCCallback)
		+GetBreakpoint(arg: rpc2.GetBreakpointIn, out: *rpc2.GetBreakpointOut): error
		+Stacktrace(arg: rpc2.StacktraceIn, out: *rpc2.StacktraceOut): error
		+Ancestors(arg: rpc2.AncestorsIn, out: *rpc2.AncestorsOut): error
		+ListBreakpoints(arg: rpc2.ListBreakpointsIn, out: *rpc2.ListBreakpointsOut): error
		+CreateBreakpoint(arg: rpc2.CreateBreakpointIn, out: *rpc2.CreateBreakpointOut): error
		+ClearBreakpoint(arg: rpc2.ClearBreakpointIn, out: *rpc2.ClearBreakpointOut): error
		+AmendBreakpoint(arg: rpc2.AmendBreakpointIn, out: *rpc2.AmendBreakpointOut): error
		+CancelNext(arg: rpc2.CancelNextIn, out: *rpc2.CancelNextOut): error
		+ListThreads(arg: rpc2.ListThreadsIn, out: *rpc2.ListThreadsOut): err: error
		+GetThread(arg: rpc2.GetThreadIn, out: *rpc2.GetThreadOut): error
		+ListPackageVars(arg: rpc2.ListPackageVarsIn, out: *rpc2.ListPackageVarsOut): error
		+ListRegisters(arg: rpc2.ListRegistersIn, out: *rpc2.ListRegistersOut): error
		+ListLocalVars(arg: rpc2.ListLocalVarsIn, out: *rpc2.ListLocalVarsOut): error
		+ListFunctionArgs(arg: rpc2.ListFunctionArgsIn, out: *rpc2.ListFunctionArgsOut): error
		+Eval(arg: rpc2.EvalIn, out: *rpc2.EvalOut): error
		+Set(arg: rpc2.SetIn, out: *rpc2.SetOut): error
		+ListSources(arg: rpc2.ListSourcesIn, out: *rpc2.ListSourcesOut): error
		+ListFunctions(arg: rpc2.ListFunctionsIn, out: *rpc2.ListFunctionsOut): error
		+ListTypes(arg: rpc2.ListTypesIn, out: *rpc2.ListTypesOut): error
		+ListGoroutines(arg: rpc2.ListGoroutinesIn, out: *rpc2.ListGoroutinesOut): error
		+AttachedToExistingProcess(arg: rpc2.AttachedToExistingProcessIn, out: *rpc2.AttachedToExistingProcessOut): error
		+FindLocation(arg: rpc2.FindLocationIn, out: *rpc2.FindLocationOut): error
		+Disassemble(arg: rpc2.DisassembleIn, out: *rpc2.DisassembleOut): error
		+Recorded(arg: rpc2.RecordedIn, out: *rpc2.RecordedOut): error
		+Checkpoint(arg: rpc2.CheckpointIn, out: *rpc2.CheckpointOut): error
		+ListCheckpoints(arg: rpc2.ListCheckpointsIn, out: *rpc2.ListCheckpointsOut): error
		+ClearCheckpoint(arg: rpc2.ClearCheckpointIn, out: *rpc2.ClearCheckpointOut): error
		+IsMulticlient(arg: rpc2.IsMulticlientIn, out: *rpc2.IsMulticlientOut): error
		+FunctionReturnLocations(in: rpc2.FunctionReturnLocationsIn, out: *rpc2.FunctionReturnLocationsOut): error
		+ListDynamicLibraries(in: rpc2.ListDynamicLibrariesIn, out: *rpc2.ListDynamicLibrariesOut): error
		+ListPackagesBuildInfo(in: rpc2.ListPackagesBuildInfoIn, out: *rpc2.ListPackagesBuildInfoOut): error
		+ExamineMemory(arg: rpc2.ExamineMemoryIn, out: *rpc2.ExaminedMemoryOut): error
		+StopRecording(arg: rpc2.StopRecordingIn, cb: service.RPCCallback)
	}
}

	rpc2.RPCServer --> service.Config
	rpc2.RPCServer --> debugger.Debugger

	rpc2.RPCServer ..> api.DebuggerCommand : <<use>>
	rpc2.RPCServer ..> rpc2.AmendBreakpointIn : <<use>>
	rpc2.RPCServer ..> rpc2.AmendBreakpointOut : <<use>>
	rpc2.RPCServer ..> rpc2.AncestorsIn : <<use>>
	rpc2.RPCServer ..> rpc2.AncestorsOut : <<use>>
	rpc2.RPCServer ..> rpc2.AttachedToExistingProcessIn : <<use>>
	rpc2.RPCServer ..> rpc2.AttachedToExistingProcessOut : <<use>>
	rpc2.RPCServer ..> rpc2.CancelNextIn : <<use>>
	rpc2.RPCServer ..> rpc2.CancelNextOut : <<use>>
	rpc2.RPCServer ..> rpc2.CheckpointIn : <<use>>
	rpc2.RPCServer ..> rpc2.CheckpointOut : <<use>>
	rpc2.RPCServer ..> rpc2.ClearBreakpointIn : <<use>>
	rpc2.RPCServer ..> rpc2.ClearBreakpointOut : <<use>>
	rpc2.RPCServer ..> rpc2.ClearCheckpointIn : <<use>>
	rpc2.RPCServer ..> rpc2.ClearCheckpointOut : <<use>>
	rpc2.RPCServer ..> rpc2.CreateBreakpointIn : <<use>>
	rpc2.RPCServer ..> rpc2.CreateBreakpointOut : <<use>>
	rpc2.RPCServer ..> rpc2.DetachIn : <<use>>
	rpc2.RPCServer ..> rpc2.DetachOut : <<use>>
	rpc2.RPCServer ..> rpc2.DisassembleIn : <<use>>
	rpc2.RPCServer ..> rpc2.DisassembleOut : <<use>>
	rpc2.RPCServer ..> rpc2.EvalIn : <<use>>
	rpc2.RPCServer ..> rpc2.EvalOut : <<use>>
	rpc2.RPCServer ..> rpc2.ExamineMemoryIn : <<use>>
	rpc2.RPCServer ..> rpc2.ExaminedMemoryOut : <<use>>
	rpc2.RPCServer ..> rpc2.FindLocationIn : <<use>>
	rpc2.RPCServer ..> rpc2.FindLocationOut : <<use>>
	rpc2.RPCServer ..> rpc2.FunctionReturnLocationsIn : <<use>>
	rpc2.RPCServer ..> rpc2.FunctionReturnLocationsOut : <<use>>
	rpc2.RPCServer ..> rpc2.GetBreakpointIn : <<use>>
	rpc2.RPCServer ..> rpc2.GetBreakpointOut : <<use>>
	rpc2.RPCServer ..> rpc2.GetThreadIn : <<use>>
	rpc2.RPCServer ..> rpc2.GetThreadOut : <<use>>
	rpc2.RPCServer ..> rpc2.IsMulticlientIn : <<use>>
	rpc2.RPCServer ..> rpc2.IsMulticlientOut : <<use>>
	rpc2.RPCServer ..> rpc2.LastModifiedIn : <<use>>
	rpc2.RPCServer ..> rpc2.LastModifiedOut : <<use>>
	rpc2.RPCServer ..> rpc2.ListBreakpointsIn : <<use>>
	rpc2.RPCServer ..> rpc2.ListBreakpointsOut : <<use>>
	rpc2.RPCServer ..> rpc2.ListCheckpointsIn : <<use>>
	rpc2.RPCServer ..> rpc2.ListCheckpointsOut : <<use>>
	rpc2.RPCServer ..> rpc2.ListDynamicLibrariesIn : <<use>>
	rpc2.RPCServer ..> rpc2.ListDynamicLibrariesOut : <<use>>
	rpc2.RPCServer ..> rpc2.ListFunctionArgsIn : <<use>>
	rpc2.RPCServer ..> rpc2.ListFunctionArgsOut : <<use>>
	rpc2.RPCServer ..> rpc2.ListFunctionsIn : <<use>>
	rpc2.RPCServer ..> rpc2.ListFunctionsOut : <<use>>
	rpc2.RPCServer ..> rpc2.ListGoroutinesIn : <<use>>
	rpc2.RPCServer ..> rpc2.ListGoroutinesOut : <<use>>
	rpc2.RPCServer ..> rpc2.ListLocalVarsIn : <<use>>
	rpc2.RPCServer ..> rpc2.ListLocalVarsOut : <<use>>
	rpc2.RPCServer ..> rpc2.ListPackageVarsIn : <<use>>
	rpc2.RPCServer ..> rpc2.ListPackageVarsOut : <<use>>
	rpc2.RPCServer ..> rpc2.ListPackagesBuildInfoIn : <<use>>
	rpc2.RPCServer ..> rpc2.ListPackagesBuildInfoOut : <<use>>
	rpc2.RPCServer ..> rpc2.ListRegistersIn : <<use>>
	rpc2.RPCServer ..> rpc2.ListRegistersOut : <<use>>
	rpc2.RPCServer ..> rpc2.ListSourcesIn : <<use>>
	rpc2.RPCServer ..> rpc2.ListSourcesOut : <<use>>
	rpc2.RPCServer ..> rpc2.ListThreadsIn : <<use>>
	rpc2.RPCServer ..> rpc2.ListThreadsOut : <<use>>
	rpc2.RPCServer ..> rpc2.ListTypesIn : <<use>>
	rpc2.RPCServer ..> rpc2.ListTypesOut : <<use>>
	rpc2.RPCServer ..> rpc2.ProcessPidIn : <<use>>
	rpc2.RPCServer ..> rpc2.ProcessPidOut : <<use>>
	rpc2.RPCServer ..> rpc2.RecordedIn : <<use>>
	rpc2.RPCServer ..> rpc2.RecordedOut : <<use>>
	rpc2.RPCServer ..> rpc2.RestartIn : <<use>>
	rpc2.RPCServer ..> rpc2.SetIn : <<use>>
	rpc2.RPCServer ..> rpc2.SetOut : <<use>>
	rpc2.RPCServer ..> rpc2.StacktraceIn : <<use>>
	rpc2.RPCServer ..> rpc2.StacktraceOut : <<use>>
	rpc2.RPCServer ..> rpc2.StateIn : <<use>>
	rpc2.RPCServer ..> rpc2.StopRecordingIn : <<use>>
	rpc2.RPCServer ..> service.RPCCallback : <<use>>

package "rpc2" {
	class "RecordedIn" as rpc2.RecordedIn <<V,Orchid>>
}

package "rpc2" {
	class "RecordedOut" as rpc2.RecordedOut <<V,Orchid>> {
		+Recorded: bool
		+TraceDirectory: string
	}
}

package "rpc2" {
	class "RestartIn" as rpc2.RestartIn <<V,Orchid>> {
		+Position: string
		+ResetArgs: bool
		+NewArgs: []string
		+Rerecord: bool
		+Rebuild: bool
		+NewRedirects: [3]string
	}
}

package "rpc2" {
	class "RestartOut" as rpc2.RestartOut <<V,Orchid>> {
		+DiscardedBreakpoints: api.DiscardedBreakpoint
	}
}

	rpc2.RestartOut --> api.DiscardedBreakpoint

package "rpc2" {
	class "SetIn" as rpc2.SetIn <<V,Orchid>> {
		+Scope: api.EvalScope
		+Symbol: string
		+Value: string
	}
}

	rpc2.SetIn --> api.EvalScope


package "rpc2" {
	class "SetOut" as rpc2.SetOut <<V,Orchid>>
}

package "rpc2" {
	class "StacktraceIn" as rpc2.StacktraceIn <<V,Orchid>> {
		+Id: int
		+Depth: int
		+Full: bool
		+Defers: bool
		+Opts: api.StacktraceOptions
		+Cfg: api.LoadConfig
	}
}

	rpc2.StacktraceIn --> api.StacktraceOptions
	rpc2.StacktraceIn --> api.LoadConfig


package "rpc2" {
	class "StacktraceOut" as rpc2.StacktraceOut <<V,Orchid>> {
		+Locations: api.Stackframe
	}
}

	rpc2.StacktraceOut --> api.Stackframe


package "rpc2" {
	class "StateIn" as rpc2.StateIn <<V,Orchid>> {
		+NonBlocking: bool
	}
}



package "rpc2" {
	class "StateOut" as rpc2.StateOut <<V,Orchid>> {
		+State: api.DebuggerState
	}
}

	rpc2.StateOut --> api.DebuggerState


package "rpc2" {
	class "StopRecordingIn" as rpc2.StopRecordingIn <<V,Orchid>>
}



package "rpc2" {
	class "StopRecordingOut" as rpc2.StopRecordingOut <<V,Orchid>>
}



package "resolve" {
	class "Binding" as resolve.Binding <<V,Orchid>> {
		+Scope: resolve.Scope
		+Index: int
		+First: syntax.Ident
	}
}

	resolve.Binding --> resolve.Scope
	resolve.Binding --> syntax.Ident


package "resolve" {
	class "Function" as resolve.Function <<V,Orchid>> {
		+Pos: syntax.Position
		+Name: string
		+Params: syntax.Expr
		+Body: syntax.Stmt
		+HasVarargs: bool
		+HasKwargs: bool
		+NumKwonlyParams: int
		+Locals: []*resolve.Binding
		+FreeVars: []*resolve.Binding
	}
}

	resolve.Function --> syntax.Position
	resolve.Function --> syntax.Expr
	resolve.Function --> syntax.Stmt


package "resolve" {
	class "Module" as resolve.Module <<V,Orchid>> {
		+Locals: []*resolve.Binding
		+Globals: []*resolve.Binding
	}
}



package "resolve" {
	class "Scope" as resolve.Scope <<V,Orchid>> {
		+String(): string
	}
}



package "resolve" {
	class "block" as resolve.block <<E,#FFCC00>> {
		-parent: *resolve.block
		-function: *resolve.Function
		-comp: syntax.Comprehension
		-bindings: map[string]*resolve.Binding
		-children: []*resolve.block
		-uses: []resolve.use
		-bind(name: string, bind: *resolve.Binding)
		+String(): string
		-resolveLocalUses()
	}
}

	resolve.block --> resolve.block
	resolve.block --> resolve.Function
	resolve.block --> syntax.Comprehension
	resolve.block --> resolve.use


package "resolve" {
	class "resolver" as resolve.resolver <<E,#FFCC00>> {
		-env: *resolve.block
		-file: *resolve.block
		-moduleLocals: []*resolve.Binding
		-moduleGlobals: []*resolve.Binding
		-globals: map[string]*resolve.Binding
		-predeclared: map[string]*resolve.Binding
		-isGlobal: func(name string) bool
		-isPredeclared: func(name string) bool
		-isUniversal: func(name string) bool
		-loops: int
		-ifstmts: int
		-errors: resolve.ErrorList
		-container(): *resolve.block
		-push(b: *resolve.block)
		-pop()
		-errorf(posn: syntax.Position, format: string, args: []interface{})
		-bind(id: syntax.Ident): bool
		-bindLocal(id: syntax.Ident): bool
		-use(id: syntax.Ident)
		-useToplevel(use: resolve.use): bind: *resolve.Binding
		-spellcheck(use: resolve.use): string
		-stmts(stmts: syntax.Stmt)
		-stmt(stmt: syntax.Stmt)
		-assign(lhs: syntax.Expr, isAugmented: bool)
		-expr(e: syntax.Expr)
		-function(function: *resolve.Function, pos: syntax.Position)
		-resolveNonLocalUses(b: *resolve.block)
		-lookupLexical(use: resolve.use, env: *resolve.block): bind: *resolve.Binding
	}
}

	resolve.resolver --> resolve.block
	resolve.resolver --> resolve.ErrorList


package "resolve" {
	class "use" as resolve.use <<V,Orchid>> {
		-id: syntax.Ident
		-env: *resolve.block
	}
}

	resolve.use --> syntax.Ident
	resolve.use --> resolve.block


package "util" {
	class "UnknownFormat" as util.UnknownFormat <<V,Orchid>> {
		-version(): int
		-dwarf64(): (bool, bool)
		-addrsize(): int
	}
}



package "util" {
	class "buf" as util.buf <<E,#FFCC00>> {
		-dwarf: dwarf.Data
		-format: util.dataFormat
		-name: string
		-off: dwarf.Offset
		-data: []byte
		+Err: error
		-slice(length: int): util.buf
		+Uint8(): uint8
		-bytes(n: int): []byte
		-skip(n: int)
		-string(): string
		+Varint(): (c: uint64, bits: uint)
		+Uint(): uint64
		+Int(): int64
		+AssertEmpty()
		-error(s: string)
	}
}

	util.buf --> util.dataFormat


package "util" {
	interface "dataFormat" as util.dataFormat {
		-addrsize(): int
		-dwarf64(): (dwarf64: bool, isKnown: bool)
		-version(): int
	}
}



package "argv" {
	class "Expander" as argv.Expander <<V,Orchid>> {
		+Expander(: string): (string, error)
	}
}


package "argv" {
	class "Parser" as argv.Parser <<E,#FFCC00>> {
		-s: *argv.Scanner
		-tokbuf: []argv.Token
		-backQuoteExpander: argv.Expander
		-stringExpander: argv.Expander
		-sections: [][]string
		-currSection: []string
		-currStrValid: bool
		-currStr: []rune
		-nextToken(): (argv.Token, error)
		-unreadToken(tok: argv.Token)
		+Parse(): ([][]string, error)
		-cmdline(): error
		-section(): error
		-spacedSection(): (u: argv.unit, ok: bool, err: error)
		-multipleUnit(): ([]argv.Token, bool, error)
		-unit(): (argv.Token, bool, error)
		-optional(typ: argv.TokenType): (bool, error)
		-accept(t: argv.TokenType, types: []argv.TokenType): bool
		-appendUnit(leftSpace: bool, u: argv.unit): error
		-endSection()
	}
}

	argv.Parser --> argv.Scanner
	argv.Parser --> argv.Token
	argv.Parser --> argv.Expander
	argv.Parser --> argv.Expander


package "argv" {
	class "Scanner" as argv.Scanner <<E,#FFCC00>> {
		-text: []rune
		-rpos: int
		-nextRune(): rune
		-unreadRune(r: rune)
		-isEscapeChars(r: rune): (rune, bool)
		+Next(): (argv.Token, error)
	}
}


	argv.Scanner ..> argv.Token : <<return>> 

package "argv" {
	class "Token" as argv.Token <<V,Orchid>> {
		+Type: argv.TokenType
		+Value: []rune
	}
}

	argv.Token --> argv.TokenType


package "argv" {
	class "TokenType" as argv.TokenType <<V,Orchid>>
}



package "argv" {
	class "unit" as argv.unit <<V,Orchid>> {
		-rightSpace: bool
		-toks: []argv.Token
	}
}

	argv.unit --> argv.Token


package "packages" {
	class "Config" as packages.Config <<V,Orchid>> {
		+Mode: packages.LoadMode
		+Context: context.Context
		+Logf: func(format string, args ...interface{})
		+Dir: string
		+Env: []string
		+BuildFlags: []string
		+Fset: token.FileSet
		+ParseFile: ast.File, error)
		+Tests: bool
		+Overlay: map[string][]byte
	}
}

	packages.Config --> packages.LoadMode


package "packages" {
	class "LoadMode" as packages.LoadMode <<V,Orchid>> {
		+String(): string
	}
}



package "packages" {
	class "Package" as packages.Package <<E,#FFCC00>> {
		+ID: string
		+Name: string
		+PkgPath: string
		+Errors: []packages.Error
		+GoFiles: []string
		+CompiledGoFiles: []string
		+OtherFiles: []string
		+ExportFile: string
		+Imports: map[string]*packages.Package
		+Types: types.Package
		+Fset: token.FileSet
		+IllTyped: bool
		+Syntax: ast.File
		+TypesInfo: types.Info
		+TypesSizes: types.Sizes
		+MarshalJSON(): ([]byte, error)
		+UnmarshalJSON(b: []byte): error
		+String(): string
	}
}

	packages.Package --> packages.Error


package "packages" {
	class "goEnv" as packages.goEnv <<V,Orchid>> {
		-modulesOn: bool
	}
}


package "packages" {
	class "goInfo" as packages.goInfo <<V,Orchid>> {
		-rootDirs: map[string]string
		-env: packages.goEnv
	}
}

	packages.goInfo --> packages.goEnv


package "packages" {
	class "goTooOldError" as packages.goTooOldError <<V,Orchid>> {
		-error: error
	}
}

	packages.goTooOldError --> error


package "packages" {
	class "importerFunc" as packages.importerFunc <<V,Orchid>> {
		+Import(path: string): (types.Package, error)
		-importerFunc(path: string): (types.Package, error)
	}
}

	packages.importerFunc ..> error : <<return>> 

package "packages" {
	class "jsonPackage" as packages.jsonPackage <<V,Orchid>> {
		+ImportPath: string
		+Dir: string
		+Name: string
		+Export: string
		+GoFiles: []string
		+CompiledGoFiles: []string
		+CFiles: []string
		+CgoFiles: []string
		+CXXFiles: []string
		+MFiles: []string
		+HFiles: []string
		+FFiles: []string
		+SFiles: []string
		+SwigFiles: []string
		+SwigCXXFiles: []string
		+SysoFiles: []string
		+Imports: []string
		+ImportMap: map[string]string
		+Deps: []string
		+TestGoFiles: []string
		+TestImports: []string
		+XTestGoFiles: []string
		+XTestImports: []string
		+ForTest: string
		+DepOnly: bool
		+Error: *packages.jsonPackageError
	}
}

	packages.jsonPackage --> packages.jsonPackageError


package "packages" {
	class "jsonPackageError" as packages.jsonPackageError <<V,Orchid>> {
		+ImportStack: []string
		+Pos: string
		+Err: string
	}
}



package "packages" {
	class "loader" as packages.loader <<E,#FFCC00>> {
		-pkgs: map[string]*packages.loaderPackage
		+Config: packages.Config
		-sizes: types.Sizes
		-parseCache: map[string]*packages.parseValue
		-parseCacheMu: sync.Mutex
		-exportMu: sync.Mutex
		-requestedMode: packages.LoadMode
		-refine(roots: []string, list: []*packages.Package): ([]*packages.Package, error)
		-loadRecursive(lpkg: *packages.loaderPackage)
		-loadPackage(lpkg: *packages.loaderPackage)
		-parseFile(filename: string): (ast.File, error)
		-parseFiles(filenames: []string): (ast.File, []error)
		-loadFromExportData(lpkg: *packages.loaderPackage): (types.Package, error)
	}
}

	packages.loader --> packages.Config
	packages.loader --> sync.Mutex
	packages.loader --> packages.LoadMode


package "packages" {
	class "loaderPackage" as packages.loaderPackage <<V,Orchid>> {
		+Package: *packages.Package
		-importErrors: map[string]error
		-loadOnce: sync.Once
		-color: uint8
		-needsrc: bool
		-needtypes: bool
		-initial: bool
	}
}

	packages.loaderPackage --> packages.Package
	packages.loaderPackage --> sync.Once


package "packages" {
	class "parseValue" as packages.parseValue <<V,Orchid>> {
		-f: ast.File
		-err: error
		-ready: chan struct{}
	}
}


package "packages" {
	class "responseDeduper" as packages.responseDeduper <<E,#FFCC00>> {
		-seenRoots: map[string]bool
		-seenPackages: map[string]*packages.Package
		-dr: *packages.driverResponse
		-init(dr: *packages.driverResponse)
		-addPackage(p: *packages.Package)
		-addRoot(id: string)
	}
}


package "line" {
	class "DebugLineInfo" as line.DebugLineInfo <<E,#FFCC00>> {
		+Prologue: *line.DebugLinePrologue
		+IncludeDirs: []string
		+FileNames: []*line.FileEntry
		+Instructions: []byte
		+Lookup: map[string]*line.FileEntry
		+Logf: func(string, ...interface{})
		-stateMachineCache: map[uint64]*line.StateMachine
		-lastMachineCache: map[uint64]*line.StateMachine
		-staticBase: uint64
		-normalizeBackslash: bool
		-ptrSize: int
		-endSeqIsValid: bool
		+AllPCsForFileLines(f: string, m: map[int][]uint64)
		+AllPCsBetween(begin: uint64, end: uint64, excludeFile: string, excludeLine: int): ([]uint64, error)
		-stateMachineForEntry(basePC: uint64): sm: *line.StateMachine
		+PCToLine(basePC: uint64, pc: uint64): (string, int)
		-stateMachineFor(basePC: uint64, pc: uint64): *line.StateMachine
		+LineToPC(filename: string, lineno: int): uint64
		+LineToPCIn(filename: string, lineno: int, basePC: uint64, startPC: uint64, endPC: uint64): uint64
		+PrologueEndPC(start: uint64, end: uint64): (pc: uint64, file: string, line: int, ok: bool)
		+FirstStmtForLine(start: uint64, end: uint64): (pc: uint64, file: string, line: int, ok: bool)
		+FirstFile(): string
	}
}

	line.DebugLineInfo --> line.DebugLinePrologue

package "line" {
	class "DebugLinePrologue" as line.DebugLinePrologue <<V,Orchid>> {
		+UnitLength: uint32
		+Version: uint16
		+Length: uint32
		+MinInstrLength: uint8
		+MaxOpPerInstr: uint8
		+InitialIsStmt: uint8
		+LineBase: int8
		+LineRange: uint8
		+OpcodeBase: uint8
		+StdOpLengths: []uint8
	}
}



package "line" {
	class "DebugLines" as line.DebugLines <<V,Orchid>>
}



package "line" {
	class "FileEntry" as line.FileEntry <<V,Orchid>> {
		+Path: string
		+DirIdx: uint64
		+LastModTime: uint64
		+Length: uint64
	}
}



package "line" {
	class "Location" as line.Location <<V,Orchid>> {
		+File: string
		+Line: int
		+Address: uint64
		+Delta: int
	}
}



package "line" {
	class "StateMachine" as line.StateMachine <<E,#FFCC00>> {
		-dbl: *line.DebugLineInfo
		-file: string
		-line: int
		-address: uint64
		-column: uint
		-isStmt: bool
		-isa: uint64
		-basicBlock: bool
		-endSeq: bool
		-lastDelta: int
		-prologueEnd: bool
		-epilogueBegin: bool
		-valid: bool
		-started: bool
		-buf: *bytes.Buffer
		-opcodes: []line.opcodefn
		-definedFiles: []*line.FileEntry
		-lastAddress: uint64
		-lastFile: string
		-lastLine: int
		-ptrSize: int
		-copy(): *line.StateMachine
		+PCToLine(pc: uint64): (string, int, bool)
		-next(): error
	}
}

	line.StateMachine --> line.DebugLineInfo
	line.StateMachine --> line.opcodefn


package "line" {
	class "formReader" as line.formReader <<E,#FFCC00>> {
		-logf: func(string, ...interface{})
		-contentTypes: []uint64
		-formCodes: []uint64
		-contentType: uint64
		-formCode: uint64
		-block: []byte
		-u64: uint64
		-i64: int64
		-str: string
		-nexti: int
		-reset()
		-next(buf: *bytes.Buffer): bool
		-readBlock(buf: *bytes.Buffer, n: uint64)
	}
}



package "line" {
	class "opcodeKind" as line.opcodeKind <<V,Orchid>>
}



package "line" {
	class "opcodefn" as line.opcodefn <<V,Orchid>> {
		-opcodefn(: *line.StateMachine, : *bytes.Buffer)
	}
}



package "core" {
	class "elfNotesHdr" as core.elfNotesHdr <<V,Orchid>> {
		+Namesz: uint32
		+Descsz: uint32
		+Type: uint32
	}
}



package "core" {
	class "linuxAMD64Thread" as core.linuxAMD64Thread <<V,Orchid>> {
		-regs: linutil.AMD64Registers
		-t: *core.linuxPrStatusAMD64
		-registers(): (proc.Registers, error)
		-pid(): int
	}
}

	core.linuxAMD64Thread --> linutil.AMD64Registers
	core.linuxAMD64Thread --> core.linuxPrStatusAMD64


package "core" {
	class "linuxARM64Thread" as core.linuxARM64Thread <<V,Orchid>> {
		-regs: linutil.ARM64Registers
		-t: *core.linuxPrStatusARM64
		-registers(): (proc.Registers, error)
		-pid(): int
	}
}

	core.linuxARM64Thread --> linutil.ARM64Registers
	core.linuxARM64Thread --> core.linuxPrStatusARM64


package "core" {
	class "linuxCoreTimeval" as core.linuxCoreTimeval <<V,Orchid>> {
		+Sec: int64
		+Usec: int64
	}
}



package "core" {
	class "linuxNTFile" as core.linuxNTFile <<V,Orchid>> {
		-linuxNTFileHdr: core.linuxNTFileHdr
		-entries: []*core.linuxNTFileEntry
	}
}

	core.linuxNTFile --> core.linuxNTFileHdr


package "core" {
	class "linuxNTFileEntry" as core.linuxNTFileEntry <<V,Orchid>> {
		+Start: uint64
		+End: uint64
		+FileOfs: uint64
	}
}



package "core" {
	class "linuxNTFileHdr" as core.linuxNTFileHdr <<V,Orchid>> {
		+Count: uint64
		+PageSize: uint64
	}
}



package "core" {
	class "linuxPrPsInfo" as core.linuxPrPsInfo <<V,Orchid>> {
		+State: uint8
		+Sname: int8
		+Zomb: uint8
		+Nice: int8
		-_: [4]uint8
		+Flag: uint64
		+Uid: uint32
		+Gid: uint32
		+Pid: int32
		+Ppid: int32
		+Pgrp: int32
		+Sid: int32
		+Fname: [16]uint8
		+Args: [80]uint8
	}
}



package "core" {
	class "linuxPrStatusAMD64" as core.linuxPrStatusAMD64 <<V,Orchid>> {
		+Siginfo: core.linuxSiginfo
		+Cursig: uint16
		-_: [2]uint8
		+Sigpend: uint64
		+Sighold: uint64
		+Pid: int32
		+Ppid: int32
		+Pgrp: int32
		+Sid: int32
		+Utime: core.linuxCoreTimeval
		+Stime: core.linuxCoreTimeval
		+CUtime: core.linuxCoreTimeval
		+CStime: core.linuxCoreTimeval
		+Reg: linutil.AMD64PtraceRegs
		+Fpvalid: int32
	}
}

	core.linuxPrStatusAMD64 --> core.linuxSiginfo
	core.linuxPrStatusAMD64 --> core.linuxCoreTimeval
	core.linuxPrStatusAMD64 --> core.linuxCoreTimeval
	core.linuxPrStatusAMD64 --> core.linuxCoreTimeval
	core.linuxPrStatusAMD64 --> core.linuxCoreTimeval
	core.linuxPrStatusAMD64 --> linutil.AMD64PtraceRegs


package "core" {
	class "note" as core.note <<V,Orchid>> {
		+Type: elf.NType
		+Name: string
		+Desc: interface{}
	}
}

	core.note --> elf.NType


package "core" {
	class "offsetReaderAt" as core.offsetReaderAt <<V,Orchid>> {
		-reader: io.ReaderAt
		-offset: uint64
		+ReadMemory(buf: []byte, addr: uint64): (n: int, err: error)
	}
}


	core.offsetReaderAt ..> error : <<return>> 

package "core" {
	class "openFn" as core.openFn <<V,Orchid>> {
		-openFn(: string, : string): (*core.process, proc.Thread, error)
	}
}



package "core" {
	interface "osThread" as core.osThread {
		-pid(): int
		-registers(): (proc.Registers, error)
	}
}



package "core" {
	class "process" as core.process <<E,#FFCC00>> {
		-mem: proc.MemoryReader
		+Threads: map[int]*core.thread
		-pid: int
		-entryPoint: uint64
		-bi: proc.BinaryInfo
		-breakpoints: proc.BreakpointMap
		+BinInfo(): proc.BinaryInfo
		+EntryPoint(): (uint64, error)
		+WriteBreakpoint(addr: uint64): (file: string, line: int, fn: proc.Function, originalData: []byte, err: error)
		+Recorded(): (bool, string)
		+Restart(: string): (proc.Thread, error)
		+ChangeDirection(: proc.Direction): error
		+GetDirection(): proc.Direction
		+When(): (string, error)
		+Checkpoint(: string): (int, error)
		+Checkpoints(): (proc.Checkpoint, error)
		+ClearCheckpoint(: int): error
		+ReadMemory(data: []byte, addr: uint64): (n: int, err: error)
		+WriteMemory(addr: uint64, data: []byte): (int, error)
		+Breakpoints(): proc.BreakpointMap
		+EraseBreakpoint(bp: proc.Breakpoint): error
		+ClearInternalBreakpoints(): error
		+ContinueOnce(): (proc.Thread, proc.StopReason, error)
		+StepInstruction(): error
		+RequestManualStop(): error
		+CheckAndClearManualStopRequest(): bool
		+Memory(): proc.MemoryReadWriter
		+Detach(: bool): error
		+Valid(): (bool, error)
		+Pid(): int
		+ResumeNotify(: chan<- struct{})
		+ThreadList(): proc.Thread
		+FindThread(threadID: int): (proc.Thread, bool)
	}
}

	core.process --> proc.MemoryReader
	core.process --> proc.BinaryInfo
	core.process --> proc.BreakpointMap

	core.process ..> proc.Function : <<return>>
	core.process ..> proc.Thread : <<return>>
	core.process ..> proc.Direction : <<use>>
	core.process ..> proc.Direction : <<return>>
	core.process ..> proc.Checkpoint : <<return>>
	core.process ..> proc.Breakpoint : <<use>>
	core.process ..> proc.StopReason : <<return>>
	core.process ..> proc.MemoryReadWriter : <<return>>

package "core" {
	class "readerEntry" as core.readerEntry <<V,Orchid>> {
		-offset: uint64
		-length: uint64
		-reader: proc.MemoryReader
	}
}

	core.readerEntry --> proc.MemoryReader


package "core" {
	class "splicedMemory" as core.splicedMemory <<E,#FFCC00>> {
		-readers: []core.readerEntry
		+Add(reader: proc.MemoryReader, off: uint64, length: uint64)
		+ReadMemory(buf: []byte, addr: uint64): (n: int, err: error)
	}
}

	core.splicedMemory --> core.readerEntry

	core.splicedMemory ..> proc.MemoryReader : <<use>> 

package "core" {
	class "thread" as core.thread <<E,#FFCC00>> {
		-th: core.osThread
		-p: *core.process
		-common: proc.CommonThread
		+ProcessMemory(): proc.MemoryReadWriter
		+Location(): (proc.Location, error)
		+Breakpoint(): proc.BreakpointState
		+ThreadID(): int
		+Registers(): (proc.Registers, error)
		+RestoreRegisters(: proc.Registers): error
		+BinInfo(): proc.BinaryInfo
		+StepInstruction(): error
		+Blocked(): bool
		+SetCurrentBreakpoint(adjustPC: bool): error
		+Common(): proc.CommonThread
		+SetPC(: uint64): error
		+SetSP(: uint64): error
		+SetDX(: uint64): error
	}
}

	core.thread --> core.osThread
	core.thread --> core.process
	core.thread --> proc.CommonThread

	core.thread ..> proc.MemoryReadWriter : <<return>> 
	core.thread ..> proc.Location : <<return>> 
	core.thread ..> proc.BreakpointState : <<return>>
	core.thread ..> proc.Registers : <<return>> 
	core.thread ..> proc.Registers : <<use>>
	core.thread ..> proc.BinaryInfo : <<return>>

package "debugger" {
	class "Config" as debugger.Config <<V,Orchid>> {
		+WorkingDir: string
		+AttachPid: int
		+CoreFile: string
		+Backend: string
		+Foreground: bool
		+DebugInfoDirectories: []string
		+CheckGoVersion: bool
		+TTY: string
		+Packages: []string
		+BuildFlags: string
		+ExecuteKind: debugger.ExecuteKind
		+Redirects: [3]string
		+DisableASLR: bool
	}
}

	debugger.Config --> debugger.ExecuteKind


package "debugger" {
	class "Debugger" as debugger.Debugger <<E,#FFCC00>> {
		-config: *debugger.Config
		-processArgs: []string
		-targetMutex: sync.Mutex
		-target: proc.Target
		-log: logrus.Entry
		-running: bool
		-runningMutex: sync.Mutex
		-stopRecording: func() error
		-recordMutex: sync.Mutex
		-canRestart(): bool
		-checkGoVersion(): error
		+Launch(processArgs: []string, wd: string): (proc.Target, error)
		-recordingStart(stop: func() error)
		-recordingDone()
		-isRecording(): bool
		-recordingRun(run: func() (string, error)): (proc.Target, error)
		+Attach(pid: int, path: string): (proc.Target, error)
		+ProcessPid(): int
		+LastModified(): time.Time
		+FunctionReturnLocations(fnName: string): ([]uint64, error)
		+Detach(kill: bool): error
		-detach(kill: bool): error
		+Restart(rerecord: bool, pos: string, resetArgs: bool, newArgs: []string, newRedirects: [3]string, rebuild: bool): (api.DiscardedBreakpoint, error)
		+State(nowait: bool): (api.DebuggerState, error)
		-state(retLoadCfg: proc.LoadConfig): (api.DebuggerState, error)
		+CreateBreakpoint(requestedBp: api.Breakpoint): (api.Breakpoint, error)
		+AmendBreakpoint(amend: api.Breakpoint): error
		+CancelNext(): error
		+ClearBreakpoint(requestedBp: api.Breakpoint): (api.Breakpoint, error)
		+Breakpoints(): api.Breakpoint
		-breakpoints(): proc.Breakpoint
		+FindBreakpoint(id: int): api.Breakpoint
		-findBreakpoint(id: int): proc.Breakpoint
		+FindBreakpointByName(name: string): api.Breakpoint
		-findBreakpointByName(name: string): api.Breakpoint
		+Threads(): (proc.Thread, error)
		+FindThread(id: int): (proc.Thread, error)
		-setRunning(running: bool)
		-isRunning(): bool
		+Command(command: api.DebuggerCommand): (api.DebuggerState, error)
		-collectBreakpointInformation(state: api.DebuggerState): error
		+Sources(filter: string): ([]string, error)
		+Functions(filter: string): ([]string, error)
		+Types(filter: string): ([]string, error)
		+PackageVariables(filter: string, cfg: proc.LoadConfig): (proc.Variable, error)
		+ThreadRegisters(threadID: int, floatingPoint: bool): (op.DwarfRegisters, error)
		+ScopeRegisters(goid: int, frame: int, deferredCall: int, floatingPoint: bool): (op.DwarfRegisters, error)
		+DwarfRegisterToString(i: int, reg: op.DwarfRegister): (string, bool, string)
		+LocalVariables(goid: int, frame: int, deferredCall: int, cfg: proc.LoadConfig): (proc.Variable, error)
		+FunctionArguments(goid: int, frame: int, deferredCall: int, cfg: proc.LoadConfig): (proc.Variable, error)
		+EvalVariableInScope(goid: int, frame: int, deferredCall: int, symbol: string, cfg: proc.LoadConfig): (proc.Variable, error)
		+SetVariableInScope(goid: int, frame: int, deferredCall: int, symbol: string, value: string): error
		+Goroutines(start: int, count: int): (proc.G, int, error)
		+Stacktrace(goroutineID: int, depth: int, opts: api.StacktraceOptions): (proc.Stackframe, error)
		+Ancestors(goroutineID: int, numAncestors: int, depth: int): (api.Ancestor, error)
		+ConvertStacktrace(rawlocs: proc.Stackframe, cfg: proc.LoadConfig): (api.Stackframe, error)
		-convertStacktrace(rawlocs: proc.Stackframe, cfg: proc.LoadConfig): (api.Stackframe, error)
		-convertDefers(defers: proc.Defer): api.Defer
		+CurrentPackage(): (string, error)
		+FindLocation(goid: int, frame: int, deferredCall: int, locStr: string, includeNonExecutableLines: bool, substitutePathRules: [][2]string): (api.Location, error)
		+Disassemble(goroutineID: int, addr1: uint64, addr2: uint64): (proc.AsmInstruction, error)
		+AsmInstructionText(inst: proc.AsmInstruction, flavour: proc.AssemblyFlavour): string
		+Recorded(): (recorded: bool, tracedir: string)
		+FindThreadReturnValues(id: int, cfg: proc.LoadConfig): (proc.Variable, error)
		+Checkpoint(where: string): (int, error)
		+Checkpoints(): (proc.Checkpoint, error)
		+ClearCheckpoint(id: int): error
		+ListDynamicLibraries(): proc.Image
		+ExamineMemory(address: uint64, length: int): ([]byte, error)
		+GetVersion(out: api.GetVersionOut): error
		+ListPackagesBuildInfo(includeFiles: bool): proc.PackageBuildInfo
		+StopRecording(): error
		+StopReason(): proc.StopReason
		+LockTarget()
		+UnlockTarget()
	}
}

	debugger.Debugger --> debugger.Config
	debugger.Debugger --> sync.Mutex
	debugger.Debugger --> proc.Target
	debugger.Debugger --> logrus.Entry
	debugger.Debugger --> sync.Mutex
	debugger.Debugger --> sync.Mutex

	debugger.Debugger ..> proc.Target : <<return>> 
	debugger.Debugger ..> proc.Target : <<return>>
	debugger.Debugger ..> time.Time : <<return>>
	debugger.Debugger ..> api.DiscardedBreakpoint : <<return>>
	debugger.Debugger ..> api.DebuggerState : <<return>>
	debugger.Debugger ..> api.Breakpoint : <<use>>
	debugger.Debugger ..> api.Breakpoint : <<return>> 
	debugger.Debugger ..> api.Breakpoint : <<use>>
	debugger.Debugger ..> api.Breakpoint : <<use>>
	debugger.Debugger ..> api.Breakpoint : <<return>> 
	debugger.Debugger ..> api.Breakpoint : <<return>>
	debugger.Debugger ..> api.Breakpoint : <<return>> 
	debugger.Debugger ..> proc.Thread : <<return>> 
	debugger.Debugger ..> proc.Thread : <<return>>
	debugger.Debugger ..> api.DebuggerCommand : <<use>>
	debugger.Debugger ..> api.DebuggerState : <<return>> 
	debugger.Debugger ..> proc.LoadConfig : <<use>>
	debugger.Debugger ..> op.DwarfRegisters : <<return>>
	debugger.Debugger ..> op.DwarfRegisters : <<return>>
	debugger.Debugger ..> op.DwarfRegister : <<use>>
	debugger.Debugger ..> proc.LoadConfig : <<use>> 
	debugger.Debugger ..> proc.LoadConfig : <<use>>
	debugger.Debugger ..> proc.LoadConfig : <<use>>
	debugger.Debugger ..> proc.Variable : <<return>> 
	debugger.Debugger ..> api.StacktraceOptions : <<use>>
	debugger.Debugger ..> proc.Stackframe : <<return>> 
	debugger.Debugger ..> api.Ancestor : <<return>>
	debugger.Debugger ..> proc.Stackframe : <<use>>
	debugger.Debugger ..> proc.LoadConfig : <<use>> 
	debugger.Debugger ..> api.Stackframe : <<return>> 
	debugger.Debugger ..> api.Location : <<return>>
	debugger.Debugger ..> proc.AsmInstruction : <<return>>
	debugger.Debugger ..> proc.AsmInstruction : <<use>>
	debugger.Debugger ..> proc.AssemblyFlavour : <<use>> 
	debugger.Debugger ..> proc.LoadConfig : <<use>> 
	debugger.Debugger ..> proc.Checkpoint : <<return>>
	debugger.Debugger ..> api.GetVersionOut : <<use>>
	debugger.Debugger ..> proc.StopReason : <<return>>

package "debugger" {
	class "ExecuteKind" as debugger.ExecuteKind <<V,Orchid>>
}



package "debugger" {
	class "breakpointsByLogicalID" as debugger.breakpointsByLogicalID <<V,Orchid>> {
		+Len(): int
		+Swap(i: int, j: int)
		+Less(i: int, j: int): bool
	}
}



package "doc" {
	class "GenManHeader" as doc.GenManHeader <<V,Orchid>> {
		+Title: string
		+Section: string
		+Date: *time.Time
		-date: string
		+Source: string
		+Manual: string
	}
}

	doc.GenManHeader --> time.Time


package "doc" {
	class "GenManTreeOptions" as doc.GenManTreeOptions <<V,Orchid>> {
		+Header: *doc.GenManHeader
		+Path: string
		+CommandSeparator: string
	}
}

	doc.GenManTreeOptions --> doc.GenManHeader


package "doc" {
	class "byName" as doc.byName <<V,Orchid>> {
		+Len(): int
		+Swap(i: int, j: int)
		+Less(i: int, j: int): bool
	}
}



package "doc" {
	class "cmdDoc" as doc.cmdDoc <<V,Orchid>> {
		+Name: string
		+Synopsis: string
		+Description: string
		+Options: []doc.cmdOption
		+InheritedOptions: []doc.cmdOption
		+Example: string
		+SeeAlso: []string
	}
}

	doc.cmdDoc --> doc.cmdOption
	doc.cmdDoc --> doc.cmdOption


package "doc" {
	class "cmdOption" as doc.cmdOption <<V,Orchid>> {
		+Name: string
		+Shorthand: string
		+DefaultValue: string
		+Usage: string
	}
}

package "syscall" {
	class "Errno" as syscall.Errno <<V,Orchid>> {
		+Error(): string
		+Is(target: error): bool
		+Temporary(): bool
		+Timeout(): bool
	}
}


package "syscall" {
	class "SysProcAttr" as syscall.SysProcAttr <<V,Orchid>> {
		+Chroot: string
		+Credential: *syscall.Credential
		+Ptrace: bool
		+Setsid: bool
		+Setpgid: bool
		+Setctty: bool
		+Noctty: bool
		+Ctty: int
		+Foreground: bool
		+Pgid: int
	}
}


package "simplelru" {
	class "EvictCallback" as simplelru.EvictCallback <<V,Orchid>> {
		+EvictCallback(key: interface{}, value: interface{})
	}
}


package "simplelru" {
	class "LRU" as simplelru.LRU <<E,#FFCC00>> {
		-size: int
		-evictList: list.List
		-items: list.Element
		-onEvict: simplelru.EvictCallback
		+Purge()
		+Add(key: interface{}, value: interface{}): evicted: bool
		+Get(key: interface{}): (value: interface{}, ok: bool)
		+Contains(key: interface{}): ok: bool
		+Peek(key: interface{}): (value: interface{}, ok: bool)
		+Remove(key: interface{}): present: bool
		+RemoveOldest(): (key: interface{}, value: interface{}, ok: bool)
		+GetOldest(): (key: interface{}, value: interface{}, ok: bool)
		+Keys(): []interface{}
		+Len(): int
		+Resize(size: int): evicted: int
		-removeOldest()
		-removeElement(e: list.Element)
	}
}

	simplelru.LRU --> simplelru.EvictCallback


package "simplelru" {
	interface "LRUCache" as simplelru.LRUCache {
		+Add(key: interface{}, value: interface{}): bool
		+Contains(key: interface{}): ok: bool
		+Get(key: interface{}): (value: interface{}, ok: bool)
		+GetOldest(): (interface{}, interface{}, bool)
		+Keys(): []interface{}
		+Len(): int
		+Peek(key: interface{}): (value: interface{}, ok: bool)
		+Purge()
		+Remove(key: interface{}): bool
		+RemoveOldest(): (interface{}, interface{}, bool)
		+Resize(: int): int
	}
}



package "simplelru" {
	class "entry" as simplelru.entry <<V,Orchid>> {
		-key: interface{}
		-value: interface{}
	}
}


package "compile" {
	class "Binding" as compile.Binding <<V,Orchid>> {
		+Name: string
		+Pos: syntax.Position
	}
}

	compile.Binding --> syntax.Position


package "compile" {
	class "Funcode" as compile.Funcode <<E,#FFCC00>> {
		+Prog: *compile.Program
		+Pos: syntax.Position
		+Name: string
		+Doc: string
		+Code: []byte
		-pclinetab: []uint16
		+Locals: []compile.Binding
		+Cells: []int
		+Freevars: []compile.Binding
		+MaxStack: int
		+NumParams: int
		+NumKwonlyParams: int
		+HasVarargs: bool
		+HasKwargs: bool
		-lntOnce: sync.Once
		-lnt: []compile.pclinecol
		+Position(pc: uint32): syntax.Position
		-decodeLNT()
	}
}

	compile.Funcode --> compile.Program
	compile.Funcode --> syntax.Position
	compile.Funcode --> compile.Binding
	compile.Funcode --> compile.Binding
	compile.Funcode --> sync.Once
	compile.Funcode --> compile.pclinecol

	compile.Funcode ..> syntax.Position : <<return>> 

package "compile" {
	class "Opcode" as compile.Opcode <<V,Orchid>> {
		+String(): string
	}
}



package "compile" {
	class "Program" as compile.Program <<V,Orchid>> {
		+Loads: []compile.Binding
		+Names: []string
		+Constants: []interface{}
		+Functions: []*compile.Funcode
		+Globals: []compile.Binding
		+Toplevel: *compile.Funcode
		+Encode(): []byte
	}
}

	compile.Program --> compile.Binding
	compile.Program --> compile.Funcode


package "compile" {
	class "block" as compile.block <<V,Orchid>> {
		-insns: []compile.insn
		-jmp: *compile.block
		-cjmp: *compile.block
		-initialstack: int
		-index: int
		-addr: uint32
	}
}

	compile.block --> compile.insn
	compile.block --> compile.block


package "compile" {
	class "decoder" as compile.decoder <<V,Orchid>> {
		-p: []byte
		-s: []byte
		-filename: *string
		-int(): int
		-int64(): int64
		-uint64(): uint64
		-string(): s: string
		-bytes(): []byte
		-binding(): compile.Binding
		-bindings(): []compile.Binding
		-ints(): []int
		-bool(): bool
		-function(): *compile.Funcode
	}
}



package "compile" {
	class "encoder" as compile.encoder <<E,#FFCC00>> {
		-p: []byte
		-s: []byte
		-tmp: [10]byte
		-int(x: int)
		-int64(x: int64)
		-uint64(x: uint64)
		-string(s: string)
		-bytes(b: []byte)
		-binding(bind: compile.Binding)
		-bindings(binds: []compile.Binding)
		-function(fn: *compile.Funcode)
	}
}



package "compile" {
	class "fcomp" as compile.fcomp <<E,#FFCC00>> {
		-fn: *compile.Funcode
		-pcomp: *compile.pcomp
		-pos: syntax.Position
		-loops: []compile.loop
		-block: *compile.block
		-generate(blocks: []*compile.block, codelen: uint32)
		-newBlock(): *compile.block
		-emit(op: compile.Opcode)
		-emit1(op: compile.Opcode, arg: uint32)
		-jump(b: *compile.block)
		-condjump(op: compile.Opcode, t: *compile.block, f: *compile.block)
		-string(s: string)
		-setPos(pos: syntax.Position)
		-set(id: syntax.Ident)
		-lookup(id: syntax.Ident)
		-stmts(stmts: syntax.Stmt)
		-stmt(stmt: syntax.Stmt)
		-assign(pos: syntax.Position, lhs: syntax.Expr)
		-assignSequence(pos: syntax.Position, lhs: syntax.Expr)
		-expr(e: syntax.Expr)
		-plus(e: syntax.BinaryExpr)
		-binop(pos: syntax.Position, op: syntax.Token)
		-call(call: syntax.CallExpr)
		-args(call: syntax.CallExpr): (op: compile.Opcode, arg: uint32)
		-tuple(elems: syntax.Expr)
		-comprehension(comp: syntax.Comprehension, clauseIndex: int)
		-function(f: resolve.Function)
		-ifelse(cond: syntax.Expr, t: *compile.block, f: *compile.block)
	}
}

	compile.fcomp --> compile.Funcode
	compile.fcomp --> compile.pcomp
	compile.fcomp --> syntax.Position
	compile.fcomp --> compile.loop
	compile.fcomp --> compile.block


package "compile" {
	class "insn" as compile.insn <<V,Orchid>> {
		-op: compile.Opcode
		-arg: uint32
		-line: int32
		-col: int32
		-stackeffect(): int
	}
}

	compile.insn --> compile.Opcode


package "compile" {
	class "loop" as compile.loop <<V,Orchid>> {
		-break_: *compile.block
		-continue_: *compile.block
	}
}

	compile.loop --> compile.block


package "compile" {
	class "pclinecol" as compile.pclinecol <<V,Orchid>> {
		-pc: uint32
		-line: int32
		-col: int32
	}
}



package "compile" {
	class "pcomp" as compile.pcomp <<V,Orchid>> {
		-prog: *compile.Program
		-names: map[string]uint32
		-constants: map[interface{}]uint32
		-functions: map[*compile.Funcode]uint32
		-function(name: string, pos: syntax.Position, stmts: syntax.Stmt, locals: resolve.Binding, freevars: resolve.Binding): *compile.Funcode
		-nameIndex(name: string): uint32
		-constantIndex(v: interface{}): uint32
		-functionIndex(fn: *compile.Funcode): uint32
	}
}

	compile.pcomp --> compile.Program


package "compile" {
	class "summand" as compile.summand <<V,Orchid>> {
		-x: syntax.Expr
		-plusPos: syntax.Position
	}
}

	compile.summand --> syntax.Expr
	compile.summand --> syntax.Position


package "gcexportdata" {
	class "importer" as gcexportdata.importer <<V,Orchid>> {
		-fset: token.FileSet
		-imports: types.Package
		+Import(importPath: string): (types.Package, error)
		+ImportFrom(importPath: string, srcDir: string, mode: types.ImportMode): (_: types.Package, err: error)
	}
}


package "dirio" {
	class "SomeType" as dirio.SomeType <<V,Orchid>> {
		+X: int
	}
}



package "dwarfbuilder" {
	class "Address" as dwarfbuilder.Address <<V,Orchid>>
}



package "dwarfbuilder" {
	class "Builder" as dwarfbuilder.Builder <<E,#FFCC00>> {
		-info: bytes.Buffer
		-loc: bytes.Buffer
		-abbrevs: []dwarfbuilder.tagDescr
		-tagStack: []*dwarfbuilder.tagState
		+Build(): (abbrev: []byte, aranges: []byte, frame: []byte, info: []byte, line: []byte, pubnames: []byte, ranges: []byte, str: []byte, loc: []byte, err: error)
		+TagOpen(tag: dwarf.Tag, name: string): dwarf.Offset
		+SetHasChildren()
		+TagClose()
		+Attr(attr: dwarf.Attr, val: interface{})
		-abbrevFor(tag: dwarfbuilder.tagDescr): byte
		-makeAbbrevTable(): []byte
		+AddCompileUnit(name: string, lowPC: uint64): dwarf.Offset
		+AddSubprogram(fnname: string, lowpc: uint64, highpc: uint64): dwarf.Offset
		+AddVariable(varname: string, typ: dwarf.Offset, loc: interface{}): dwarf.Offset
		+AddBaseType(typename: string, encoding: dwarfbuilder.Encoding, byteSz: uint16): dwarf.Offset
		+AddStructType(typename: string, byteSz: uint16): dwarf.Offset
		+AddMember(fieldname: string, typ: dwarf.Offset, memberLoc: []byte): dwarf.Offset
		+AddPointerType(typename: string, typ: dwarf.Offset): dwarf.Offset
	}
}

	dwarfbuilder.Builder --> dwarfbuilder.tagDescr
	dwarfbuilder.Builder ..> error : <<return>>
	dwarfbuilder.Builder ..> dwarf.Attr : <<use>> 
	dwarfbuilder.Builder ..> dwarfbuilder.Encoding : <<use>> 

package "dwarfbuilder" {
	class "Encoding" as dwarfbuilder.Encoding <<V,Orchid>>
}


package "dwarfbuilder" {
	class "Form" as dwarfbuilder.Form <<V,Orchid>>
}



package "dwarfbuilder" {
	class "LocEntry" as dwarfbuilder.LocEntry <<V,Orchid>> {
		+Lowpc: uint64
		+Highpc: uint64
		+Loc: []byte
	}
}



package "dwarfbuilder" {
	class "tagDescr" as dwarfbuilder.tagDescr <<V,Orchid>> {
		-tag: dwarf.Tag
		-attr: dwarf.Attr
		-form: []dwarfbuilder.Form
		-children: bool
	}
}

	dwarfbuilder.tagDescr --> dwarf.Attr
	dwarfbuilder.tagDescr --> dwarfbuilder.Form


package "dwarfbuilder" {
	class "tagState" as dwarfbuilder.tagState <<V,Orchid>> {
		-off: dwarf.Offset
		-tagDescr: dwarfbuilder.tagDescr
	}
}

	dwarfbuilder.tagState --> dwarfbuilder.tagDescr


package "version" {
	class "Version" as version.Version <<V,Orchid>> {
		+Major: string
		+Minor: string
		+Patch: string
		+Metadata: string
		+Build: string
		+String(): string
	}
}



package "loclist" {
	class "Dwarf2Reader" as loclist.Dwarf2Reader <<E,#FFCC00>> {
		-data: []byte
		-cur: int
		-ptrSz: int
		+Empty(): bool
		+Seek(off: int)
		+Next(e: *loclist.Entry): bool
		+Find(off: int, staticBase: uint64, base: uint64, pc: uint64, debugAddr: godwarf.DebugAddr): (*loclist.Entry, error)
		-read(sz: int): []byte
		-oneAddr(): uint64
	}
}


	loclist.Dwarf2Reader ..> loclist.Entry
	loclist.Dwarf2Reader ..> godwarf.DebugAddr : <<use>> 

package "loclist" {
	class "Dwarf5Reader" as loclist.Dwarf5Reader <<V,Orchid>> {
		-byteOrder: binary.ByteOrder
		-ptrSz: int
		-data: []byte
		+Empty(): bool
		+Find(off: int, staticBase: uint64, base: uint64, pc: uint64, debugAddr: godwarf.DebugAddr): (*loclist.Entry, error)
	}
}


	loclist.Dwarf5Reader ..> godwarf.DebugAddr : <<use>> 
	loclist.Dwarf5Reader ..> loclist.Entry : <<return>> 

package "loclist" {
	class "Entry" as loclist.Entry <<V,Orchid>> {
		+LowPC: uint64
		+HighPC: uint64
		+Instr: []byte
		+BaseAddressSelection(): bool
	}
}



package "loclist" {
	interface "Reader" as loclist.Reader {
		+Empty(): bool
		+Find(off: int, staticBase: uint64, base: uint64, pc: uint64, debugAddr: godwarf.DebugAddr): (*loclist.Entry, error)
	}
}


	loclist.Reader ..> godwarf.DebugAddr : <<use>> 
	loclist.Reader ..> loclist.Entry : <<return>> 

package "loclist" {
	class "loclistsIterator" as loclist.loclistsIterator <<E,#FFCC00>> {
		-rdr: *loclist.Dwarf5Reader
		-debugAddr: godwarf.DebugAddr
		-buf: *bytes.Buffer
		-staticBase: uint64
		-base: uint64
		-onRange: bool
		-atEnd: bool
		-start: uint64
		-end: uint64
		-instr: []byte
		-defaultInstr: []byte
		-err: error
		-next(): bool
		-readInstr()
	}
}

	loclist.loclistsIterator --> loclist.Dwarf5Reader
	loclist.loclistsIterator --> godwarf.DebugAddr


package "api" {
	class "Ancestor" as api.Ancestor <<V,Orchid>> {
		+ID: int64
		+Stack: []api.Stackframe
		+Unreadable: string
	}
}

	api.Ancestor --> api.Stackframe


package "api" {
	class "AsmInstruction" as api.AsmInstruction <<V,Orchid>> {
		+Loc: api.Location
		+DestLoc: *api.Location
		+Text: string
		+Bytes: []byte
		+Breakpoint: bool
		+AtPC: bool
	}
}

	api.AsmInstruction --> api.Location


package "api" {
	class "AsmInstructions" as api.AsmInstructions <<V,Orchid>>
}


api.AsmInstructions *-- api.AsmInstruction
package "api" {
	class "AssemblyFlavour" as api.AssemblyFlavour <<V,Orchid>>
}



package "api" {
	class "Breakpoint" as api.Breakpoint <<V,Orchid>> {
		+ID: int
		+Name: string
		+Addr: uint64
		+Addrs: []uint64
		+File: string
		+Line: int
		+FunctionName: string
		+Cond: string
		+Tracepoint: bool
		+TraceReturn: bool
		+Goroutine: bool
		+Stacktrace: int
		+Variables: []string
		+LoadArgs: *api.LoadConfig
		+LoadLocals: *api.LoadConfig
		+HitCount: map[string]uint64
		+TotalHitCount: uint64
	}
}

	api.Breakpoint --> api.LoadConfig


package "api" {
	class "BreakpointInfo" as api.BreakpointInfo <<V,Orchid>> {
		+Stacktrace: []api.Stackframe
		+Goroutine: *api.Goroutine
		+Variables: []api.Variable
		+Arguments: []api.Variable
		+Locals: []api.Variable
	}
}

	api.BreakpointInfo --> api.Stackframe
	api.BreakpointInfo --> api.Goroutine
	api.BreakpointInfo --> api.Variable


package "api" {
	class "Checkpoint" as api.Checkpoint <<V,Orchid>> {
		+ID: int
		+When: string
		+Where: string
	}
}



package "api" {
	class "DebuggerCommand" as api.DebuggerCommand <<V,Orchid>> {
		+Name: string
		+ThreadID: int
		+GoroutineID: int
		+ReturnInfoLoadConfig: *api.LoadConfig
		+Expr: string
		+UnsafeCall: bool
	}
}

	api.DebuggerCommand --> api.LoadConfig


package "api" {
	class "DebuggerState" as api.DebuggerState <<V,Orchid>> {
		+Running: bool
		+Recording: bool
		+CurrentThread: *api.Thread
		+SelectedGoroutine: *api.Goroutine
		+Threads: []*api.Thread
		+NextInProgress: bool
		+Exited: bool
		+ExitStatus: int
		+When: string
		+Err: error
	}
}

	api.DebuggerState --> api.Thread
	api.DebuggerState --> api.Goroutine


package "api" {
	class "Defer" as api.Defer <<V,Orchid>> {
		+DeferredLoc: api.Location
		+DeferLoc: api.Location
		+SP: uint64
		+Unreadable: string
	}
}

	api.Defer --> api.Location


package "api" {
	class "DiscardedBreakpoint" as api.DiscardedBreakpoint <<V,Orchid>> {
		+Breakpoint: *api.Breakpoint
		+Reason: string
	}
}

	api.DiscardedBreakpoint --> api.Breakpoint


package "api" {
	class "EvalScope" as api.EvalScope <<V,Orchid>> {
		+GoroutineID: int
		+Frame: int
		+DeferredCall: int
	}
}



package "api" {
	class "Function" as api.Function <<V,Orchid>> {
		+Name_: string
		+Value: uint64
		+Type: byte
		+GoType: uint64
		+Optimized: bool
		+Name(): string
	}
}

package "api" {
	class "GetVersionIn" as api.GetVersionIn <<V,Orchid>>
}


package "api" {
	class "GetVersionOut" as api.GetVersionOut <<V,Orchid>> {
		+DelveVersion: string
		+APIVersion: int
		+Backend: string
		+TargetGoVersion: string
		+MinSupportedVersionOfGo: string
		+MaxSupportedVersionOfGo: string
	}
}



package "api" {
	class "Goroutine" as api.Goroutine <<V,Orchid>> {
		+ID: int
		+CurrentLoc: api.Location
		+UserCurrentLoc: api.Location
		+GoStatementLoc: api.Location
		+StartLoc: api.Location
		+ThreadID: int
		+WaitSince: int64
		+WaitReason: int64
		+Unreadable: string
		+Labels: map[string]string
	}
}

	api.Goroutine --> api.Location


package "api" {
	class "Image" as api.Image <<V,Orchid>> {
		+Path: string
		+Address: uint64
	}
}



package "api" {
	class "LoadConfig" as api.LoadConfig <<V,Orchid>> {
		+FollowPointers: bool
		+MaxVariableRecurse: int
		+MaxStringLen: int
		+MaxArrayValues: int
		+MaxStructFields: int
	}
}



package "api" {
	class "Location" as api.Location <<V,Orchid>> {
		+PC: uint64
		+File: string
		+Line: int
		+Function: *api.Function
		+PCs: []uint64
	}
}

	api.Location --> api.Function


package "api" {
	class "PackageBuildInfo" as api.PackageBuildInfo <<V,Orchid>> {
		+ImportPath: string
		+DirectoryPath: string
		+Files: []string
	}
}



package "api" {
	class "Register" as api.Register <<V,Orchid>> {
		+Name: string
		+Value: string
		+DwarfNumber: int
	}
}



package "api" {
	class "Registers" as api.Registers <<V,Orchid>> {
		+String(): string
	}
}


api.Registers *-- api.Register
package "api" {
	class "SetAPIVersionIn" as api.SetAPIVersionIn <<V,Orchid>> {
		+APIVersion: int
	}
}



package "api" {
	class "SetAPIVersionOut" as api.SetAPIVersionOut <<V,Orchid>>
}



package "api" {
	class "Stackframe" as api.Stackframe <<V,Orchid>> {
		+Location: api.Location
		+Locals: []api.Variable
		+Arguments: []api.Variable
		+FrameOffset: int64
		+FramePointerOffset: int64
		+Defers: []api.Defer
		+Bottom: bool
		+Err: string
		+Var(name: string): *api.Variable
	}
}

	api.Stackframe --> api.Location
	api.Stackframe --> api.Variable
	api.Stackframe --> api.Defer

package "api" {
	class "StacktraceOptions" as api.StacktraceOptions <<V,Orchid>>
}



package "api" {
	class "Thread" as api.Thread <<V,Orchid>> {
		+ID: int
		+PC: uint64
		+File: string
		+Line: int
		+Function: *api.Function
		+GoroutineID: int
		+Breakpoint: *api.Breakpoint
		+BreakpointInfo: *api.BreakpointInfo
		+ReturnValues: []api.Variable
		+CallReturn: bool
	}
}

	api.Thread --> api.Function
	api.Thread --> api.Breakpoint
	api.Thread --> api.BreakpointInfo
	api.Thread --> api.Variable


package "api" {
	class "Variable" as api.Variable <<E,#FFCC00>> {
		+Name: string
		+Addr: uint64
		+OnlyAddr: bool
		+Type: string
		+RealType: string
		+Flags: api.VariableFlags
		+Kind: reflect.Kind
		+Value: string
		+Len: int64
		+Cap: int64
		+Children: []api.Variable
		+Base: uint64
		+Unreadable: string
		+LocationExpr: string
		+DeclLine: int64
		+SinglelineString(): string
		+MultilineString(indent: string): string
		-writeTo(buf: io.Writer, top: bool, newlines: bool, includeType: bool, indent: string)
		-writeStringTo(buf: io.Writer)
		-writeSliceTo(buf: io.Writer, newlines: bool, includeType: bool, indent: string)
		-writeArrayTo(buf: io.Writer, newlines: bool, includeType: bool, indent: string)
		-writeStructTo(buf: io.Writer, newlines: bool, includeType: bool, indent: string)
		-writeMapTo(buf: io.Writer, newlines: bool, includeType: bool, indent: string)
		-shouldNewlineArray(newlines: bool): bool
		-recursiveKind(): (reflect.Kind, bool)
		-shouldNewlineStruct(newlines: bool): bool
		-writeSliceOrArrayTo(buf: io.Writer, newlines: bool, indent: string)
	}
}

	api.Variable --> api.VariableFlags
	api.Variable --> api.Variable


package "api" {
	class "VariableFlags" as api.VariableFlags <<V,Orchid>>
}



package "blackfriday" {
	class "Html" as blackfriday.Html <<E,#FFCC00>> {
		-flags: int
		-closeTag: string
		-title: string
		-css: string
		-parameters: blackfriday.HtmlRendererParameters
		-tocMarker: int
		-headerCount: int
		-currentLevel: int
		-toc: *bytes.Buffer
		-headerIDs: map[string]int
		-smartypants: *blackfriday.smartypantsRenderer
		+GetFlags(): int
		+TitleBlock(out: *bytes.Buffer, text: []byte)
		+Header(out: *bytes.Buffer, text: func() bool, level: int, id: string)
		+BlockHtml(out: *bytes.Buffer, text: []byte)
		+HRule(out: *bytes.Buffer)
		+BlockCode(out: *bytes.Buffer, text: []byte, info: string)
		+BlockQuote(out: *bytes.Buffer, text: []byte)
		+Table(out: *bytes.Buffer, header: []byte, body: []byte, columnData: []int)
		+TableRow(out: *bytes.Buffer, text: []byte)
		+TableHeaderCell(out: *bytes.Buffer, text: []byte, align: int)
		+TableCell(out: *bytes.Buffer, text: []byte, align: int)
		+Footnotes(out: *bytes.Buffer, text: func() bool)
		+FootnoteItem(out: *bytes.Buffer, name: []byte, text: []byte, flags: int)
		+List(out: *bytes.Buffer, text: func() bool, flags: int)
		+ListItem(out: *bytes.Buffer, text: []byte, flags: int)
		+Paragraph(out: *bytes.Buffer, text: func() bool)
		+AutoLink(out: *bytes.Buffer, link: []byte, kind: int)
		+CodeSpan(out: *bytes.Buffer, text: []byte)
		+DoubleEmphasis(out: *bytes.Buffer, text: []byte)
		+Emphasis(out: *bytes.Buffer, text: []byte)
		-maybeWriteAbsolutePrefix(out: *bytes.Buffer, link: []byte)
		+Image(out: *bytes.Buffer, link: []byte, title: []byte, alt: []byte)
		+LineBreak(out: *bytes.Buffer)
		+Link(out: *bytes.Buffer, link: []byte, title: []byte, content: []byte)
		+RawHtmlTag(out: *bytes.Buffer, text: []byte)
		+TripleEmphasis(out: *bytes.Buffer, text: []byte)
		+StrikeThrough(out: *bytes.Buffer, text: []byte)
		+FootnoteRef(out: *bytes.Buffer, ref: []byte, id: int)
		+Entity(out: *bytes.Buffer, entity: []byte)
		+NormalText(out: *bytes.Buffer, text: []byte)
		+Smartypants(out: *bytes.Buffer, text: []byte)
		+DocumentHeader(out: *bytes.Buffer)
		+DocumentFooter(out: *bytes.Buffer)
		+TocHeaderWithAnchor(text: []byte, level: int, anchor: string)
		+TocHeader(text: []byte, level: int)
		+TocFinalize()
		-ensureUniqueHeaderID(id: string): string
	}
}

	blackfriday.Html --> blackfriday.HtmlRendererParameters
	blackfriday.Html --> blackfriday.smartypantsRenderer


package "blackfriday" {
	class "HtmlRendererParameters" as blackfriday.HtmlRendererParameters <<V,Orchid>> {
		+AbsolutePrefix: string
		+FootnoteAnchorPrefix: string
		+FootnoteReturnLinkContents: string
		+HeaderIDPrefix: string
		+HeaderIDSuffix: string
	}
}



package "blackfriday" {
	class "Latex" as blackfriday.Latex <<E,#FFCC00>> {
		+GetFlags(): int
		+BlockCode(out: *bytes.Buffer, text: []byte, info: string)
		+TitleBlock(out: *bytes.Buffer, text: []byte)
		+BlockQuote(out: *bytes.Buffer, text: []byte)
		+BlockHtml(out: *bytes.Buffer, text: []byte)
		+Header(out: *bytes.Buffer, text: func() bool, level: int, id: string)
		+HRule(out: *bytes.Buffer)
		+List(out: *bytes.Buffer, text: func() bool, flags: int)
		+ListItem(out: *bytes.Buffer, text: []byte, flags: int)
		+Paragraph(out: *bytes.Buffer, text: func() bool)
		+Table(out: *bytes.Buffer, header: []byte, body: []byte, columnData: []int)
		+TableRow(out: *bytes.Buffer, text: []byte)
		+TableHeaderCell(out: *bytes.Buffer, text: []byte, align: int)
		+TableCell(out: *bytes.Buffer, text: []byte, align: int)
		+Footnotes(out: *bytes.Buffer, text: func() bool)
		+FootnoteItem(out: *bytes.Buffer, name: []byte, text: []byte, flags: int)
		+AutoLink(out: *bytes.Buffer, link: []byte, kind: int)
		+CodeSpan(out: *bytes.Buffer, text: []byte)
		+DoubleEmphasis(out: *bytes.Buffer, text: []byte)
		+Emphasis(out: *bytes.Buffer, text: []byte)
		+Image(out: *bytes.Buffer, link: []byte, title: []byte, alt: []byte)
		+LineBreak(out: *bytes.Buffer)
		+Link(out: *bytes.Buffer, link: []byte, title: []byte, content: []byte)
		+RawHtmlTag(out: *bytes.Buffer, tag: []byte)
		+TripleEmphasis(out: *bytes.Buffer, text: []byte)
		+StrikeThrough(out: *bytes.Buffer, text: []byte)
		+FootnoteRef(out: *bytes.Buffer, ref: []byte, id: int)
		+Entity(out: *bytes.Buffer, entity: []byte)
		+NormalText(out: *bytes.Buffer, text: []byte)
		+DocumentHeader(out: *bytes.Buffer)
		+DocumentFooter(out: *bytes.Buffer)
	}
}



package "blackfriday" {
	class "Options" as blackfriday.Options <<V,Orchid>> {
		+Extensions: int
		+ReferenceOverride: blackfriday.ReferenceOverrideFunc
	}
}

	blackfriday.Options --> blackfriday.ReferenceOverrideFunc


package "blackfriday" {
	class "Reference" as blackfriday.Reference <<V,Orchid>> {
		+Link: string
		+Title: string
		+Text: string
	}
}



package "blackfriday" {
	class "ReferenceOverrideFunc" as blackfriday.ReferenceOverrideFunc <<V,Orchid>> {
		+ReferenceOverrideFunc(reference: string): (ref: *blackfriday.Reference, overridden: bool)
	}
}


	blackfriday.ReferenceOverrideFunc ..> blackfriday.Reference : <<return>> 

package "blackfriday" {
	interface "Renderer" as blackfriday.Renderer {
		+AutoLink(out: *bytes.Buffer, link: []byte, kind: int)
		+BlockCode(out: *bytes.Buffer, text: []byte, infoString: string)
		+BlockHtml(out: *bytes.Buffer, text: []byte)
		+BlockQuote(out: *bytes.Buffer, text: []byte)
		+CodeSpan(out: *bytes.Buffer, text: []byte)
		+DocumentFooter(out: *bytes.Buffer)
		+DocumentHeader(out: *bytes.Buffer)
		+DoubleEmphasis(out: *bytes.Buffer, text: []byte)
		+Emphasis(out: *bytes.Buffer, text: []byte)
		+Entity(out: *bytes.Buffer, entity: []byte)
		+FootnoteItem(out: *bytes.Buffer, name: []byte, text: []byte, flags: int)
		+FootnoteRef(out: *bytes.Buffer, ref: []byte, id: int)
		+Footnotes(out: *bytes.Buffer, text: func() bool)
		+GetFlags(): int
		+HRule(out: *bytes.Buffer)
		+Header(out: *bytes.Buffer, text: func() bool, level: int, id: string)
		+Image(out: *bytes.Buffer, link: []byte, title: []byte, alt: []byte)
		+LineBreak(out: *bytes.Buffer)
		+Link(out: *bytes.Buffer, link: []byte, title: []byte, content: []byte)
		+List(out: *bytes.Buffer, text: func() bool, flags: int)
		+ListItem(out: *bytes.Buffer, text: []byte, flags: int)
		+NormalText(out: *bytes.Buffer, text: []byte)
		+Paragraph(out: *bytes.Buffer, text: func() bool)
		+RawHtmlTag(out: *bytes.Buffer, tag: []byte)
		+StrikeThrough(out: *bytes.Buffer, text: []byte)
		+Table(out: *bytes.Buffer, header: []byte, body: []byte, columnData: []int)
		+TableCell(out: *bytes.Buffer, text: []byte, flags: int)
		+TableHeaderCell(out: *bytes.Buffer, text: []byte, flags: int)
		+TableRow(out: *bytes.Buffer, text: []byte)
		+TitleBlock(out: *bytes.Buffer, text: []byte)
		+TripleEmphasis(out: *bytes.Buffer, text: []byte)
	}
}



package "blackfriday" {
	class "inlineParser" as blackfriday.inlineParser <<V,Orchid>> {
		-inlineParser(p: *blackfriday.parser, out: *bytes.Buffer, data: []byte, offset: int): int
	}
}



package "blackfriday" {
	class "linkType" as blackfriday.linkType <<V,Orchid>>
}



package "blackfriday" {
	class "parser" as blackfriday.parser <<E,#FFCC00>> {
		-r: blackfriday.Renderer
		-refOverride: blackfriday.ReferenceOverrideFunc
		-refs: map[string]*blackfriday.reference
		-inlineCallback: [256]blackfriday.inlineParser
		-flags: int
		-nesting: int
		-maxNesting: int
		-insideLink: bool
		-notes: []*blackfriday.reference
		-notesRecord: map[string]struct{}
		-inline(out: *bytes.Buffer, data: []byte)
		-inlineHTMLComment(out: *bytes.Buffer, data: []byte): int
		-getRef(refid: string): (ref: *blackfriday.reference, found: bool)
		-isFootnote(ref: *blackfriday.reference): bool
		-block(out: *bytes.Buffer, data: []byte)
		-isPrefixHeader(data: []byte): bool
		-prefixHeader(out: *bytes.Buffer, data: []byte): int
		-isUnderlinedHeader(data: []byte): int
		-titleBlock(out: *bytes.Buffer, data: []byte, doRender: bool): int
		-html(out: *bytes.Buffer, data: []byte, doRender: bool): int
		-renderHTMLBlock(out: *bytes.Buffer, data: []byte, start: int, doRender: bool): int
		-htmlComment(out: *bytes.Buffer, data: []byte, doRender: bool): int
		-htmlCDATA(out: *bytes.Buffer, data: []byte, doRender: bool): int
		-htmlHr(out: *bytes.Buffer, data: []byte, doRender: bool): int
		-htmlFindTag(data: []byte): (string, bool)
		-htmlFindEnd(tag: string, data: []byte): int
		-isEmpty(data: []byte): int
		-isHRule(data: []byte): bool
		-fencedCodeBlock(out: *bytes.Buffer, data: []byte, doRender: bool): int
		-table(out: *bytes.Buffer, data: []byte): int
		-tableHeader(out: *bytes.Buffer, data: []byte): (size: int, columns: []int)
		-tableRow(out: *bytes.Buffer, data: []byte, columns: []int, header: bool)
		-quotePrefix(data: []byte): int
		-terminateBlockquote(data: []byte, beg: int, end: int): bool
		-quote(out: *bytes.Buffer, data: []byte): int
		-codePrefix(data: []byte): int
		-code(out: *bytes.Buffer, data: []byte): int
		-uliPrefix(data: []byte): int
		-oliPrefix(data: []byte): int
		-dliPrefix(data: []byte): int
		-list(out: *bytes.Buffer, data: []byte, flags: int): int
		-listItem(out: *bytes.Buffer, data: []byte, flags: *int): int
		-renderParagraph(out: *bytes.Buffer, data: []byte)
		-paragraph(out: *bytes.Buffer, data: []byte): int
	}
}

	blackfriday.parser --> blackfriday.Renderer
	blackfriday.parser --> blackfriday.ReferenceOverrideFunc


package "blackfriday" {
	class "reference" as blackfriday.reference <<V,Orchid>> {
		-link: []byte
		-title: []byte
		-noteId: int
		-hasBlock: bool
		-text: []byte
		+String(): string
	}
}



package "blackfriday" {
	class "smartCallback" as blackfriday.smartCallback <<V,Orchid>> {
		-smartCallback(out: *bytes.Buffer, smrt: *blackfriday.smartypantsData, previousChar: byte, text: []byte): int
	}
}



package "blackfriday" {
	class "smartypantsData" as blackfriday.smartypantsData <<V,Orchid>> {
		-inSingleQuote: bool
		-inDoubleQuote: bool
	}
}



package "blackfriday" {
	class "smartypantsRenderer" as blackfriday.smartypantsRenderer <<V,Orchid>>
}




package "config" {
	class "Config" as config.Config <<V,Orchid>> {
		+Aliases: map[string][]string
		+SubstitutePath: config.SubstitutePathRules
		+MaxStringLen: *int
		+MaxArrayValues: *int
		+MaxVariableRecurse: *int
		+DisassembleFlavor: *string
		+ShowLocationExpr: bool
		+SourceListLineColor: int
		+SourceListLineCount: *int
		+DebugInfoDirectories: []string
		+GetSourceListLineCount(): int
	}
}

	config.Config --> config.SubstitutePathRules


package "config" {
	class "SubstitutePathRule" as config.SubstitutePathRule <<V,Orchid>> {
		+From: string
		+To: string
	}
}



package "config" {
	class "SubstitutePathRules" as config.SubstitutePathRules <<V,Orchid>>
}


config.SubstitutePathRules *-- config.SubstitutePathRule
package "fbsdutil" {
	class "AMD64PtraceRegs" as fbsdutil.AMD64PtraceRegs <<V,Orchid>> {
		+R15: int64
		+R14: int64
		+R13: int64
		...
	}
}



package "fbsdutil" {
	class "AMD64Registers" as fbsdutil.AMD64Registers <<V,Orchid>> {
		+Regs: *fbsdutil.AMD64PtraceRegs
		+Fpregs: proc.Register
		+Fpregset: amd64util.AMD64Xstate
		...
	}
}

	fbsdutil.AMD64Registers --> fbsdutil.AMD64PtraceRegs
	fbsdutil.AMD64Registers --> proc.Register
	fbsdutil.AMD64Registers --> amd64util.AMD64Xstate


package "service" {
	interface "Client" as service.Client {
		+AmendBreakpoint(: api.Breakpoint): error
		+Ancestors(goroutineID: int, numAncestors: int, depth: int): (api.Ancestor, error)
		+AttachedToExistingProcess(): bool
		+Call(goroutineID: int, expr: string, unsafe: bool): (api.DebuggerState, error)
		+CallAPI(method: string, args: interface{}, reply: interface{}): error
		+CancelNext(): error
		+Checkpoint(where: string): (checkpointID: int, err: error)
		+ClearBreakpoint(id: int): (api.Breakpoint, error)
		+ClearBreakpointByName(name: string): (api.Breakpoint, error)
		+ClearCheckpoint(id: int): error
		+Continue(): api.DebuggerState
		+CreateBreakpoint(: api.Breakpoint): (api.Breakpoint, error)
		+Detach(killProcess: bool): error
		+DirectionCongruentContinue(): api.DebuggerState
		+DisassemblePC(scope: api.EvalScope, pc: uint64, flavour: api.AssemblyFlavour): (api.AsmInstructions, error)
		+DisassembleRange(scope: api.EvalScope, startPC: uint64, endPC: uint64, flavour: api.AssemblyFlavour): (api.AsmInstructions, error)
		+Disconnect(cont: bool): error
		+EvalVariable(scope: api.EvalScope, symbol: string, cfg: api.LoadConfig): (api.Variable, error)
		+ExamineMemory(address: uint64, length: int): ([]byte, bool, error)
		+FindLocation(scope: api.EvalScope, loc: string, findInstruction: bool, substitutePathRules: [][2]string): (api.Location, error)
		+GetBreakpoint(id: int): (api.Breakpoint, error)
		+GetBreakpointByName(name: string): (api.Breakpoint, error)
		+GetState(): (api.DebuggerState, error)
		+GetStateNonBlocking(): (api.DebuggerState, error)
		+GetThread(id: int): (api.Thread, error)
		+Halt(): (api.DebuggerState, error)
		+IsMulticlient(): bool
		+LastModified(): time.Time
		+ListBreakpoints(): (api.Breakpoint, error)
		+ListCheckpoints(): (api.Checkpoint, error)
		+ListDynamicLibraries(): (api.Image, error)
		+ListFunctionArgs(scope: api.EvalScope, cfg: api.LoadConfig): (api.Variable, error)
		+ListFunctions(filter: string): ([]string, error)
		+ListGoroutines(start: int, count: int): (api.Goroutine, int, error)
		+ListLocalVariables(scope: api.EvalScope, cfg: api.LoadConfig): (api.Variable, error)
		+ListPackageVariables(filter: string, cfg: api.LoadConfig): (api.Variable, error)
		+ListScopeRegisters(scope: api.EvalScope, includeFp: bool): (api.Registers, error)
		+ListSources(filter: string): ([]string, error)
		+ListThreadRegisters(threadID: int, includeFp: bool): (api.Registers, error)
		+ListThreads(): (api.Thread, error)
		+ListTypes(filter: string): ([]string, error)
		+Next(): (api.DebuggerState, error)
		+ProcessPid(): int
		+Recorded(): bool
		+Restart(rebuild: bool): (api.DiscardedBreakpoint, error)
		+RestartFrom(rerecord: bool, pos: string, resetArgs: bool, newArgs: []string, newRedirects: [3]string, rebuild: bool): (api.DiscardedBreakpoint, error)
		+ReverseNext(): (api.DebuggerState, error)
		+ReverseStep(): (api.DebuggerState, error)
		+ReverseStepInstruction(): (api.DebuggerState, error)
		+ReverseStepOut(): (api.DebuggerState, error)
		+Rewind(): api.DebuggerState
		+SetReturnValuesLoadConfig(: api.LoadConfig)
		+SetVariable(scope: api.EvalScope, symbol: string, value: string): error
		+Stacktrace(goroutineID: int, depth: int, opts: api.StacktraceOptions, cfg: api.LoadConfig): (api.Stackframe, error)
		+Step(): (api.DebuggerState, error)
		+StepInstruction(): (api.DebuggerState, error)
		+StepOut(): (api.DebuggerState, error)
		+StopRecording(): error
		+SwitchGoroutine(goroutineID: int): (api.DebuggerState, error)
		+SwitchThread(threadID: int): (api.DebuggerState, error)
		+TraceDirectory(): (string, error)
	}
}

	service.Client ..> api.Ancestor : <<return>>
	service.Client ..> api.AsmInstructions : <<return>>
	service.Client ..> api.AssemblyFlavour : <<use>>
	service.Client ..> api.Breakpoint : <<return>>
	service.Client ..> api.Breakpoint : <<use>>
	service.Client ..> api.Checkpoint : <<return>>
	service.Client ..> api.DebuggerState : <<return>>
	service.Client ..> api.DiscardedBreakpoint : <<return>>
	service.Client ..> api.EvalScope : <<use>>
	service.Client ..> api.Image : <<return>>
	service.Client ..> api.LoadConfig : <<use>>
	service.Client ..> api.Location : <<return>>
	service.Client ..> api.Registers : <<return>>
	service.Client ..> api.Stackframe : <<return>>
	service.Client ..> api.StacktraceOptions : <<use>>
	service.Client ..> api.Thread : <<return>>
	service.Client ..> api.Variable : <<return>>
	service.Client ..> time.Time : <<return>>


package "service" {
	class "Config" as service.Config <<V,Orchid>> {
		+Debugger: debugger.Config
		+Listener: net.Listener
		+ProcessArgs: []string
		+AcceptMulti: bool
		+APIVersion: int
		+CheckLocalConnUser: bool
		+DisconnectChan: chan<- struct{}
	}
}

	service.Config --> debugger.Config


package "service" {
	interface "RPCCallback" as service.RPCCallback {
		+Return(out: interface{}, err: error)
	}
}


package "service" {
	interface "Server" as service.Server {
		+Run(): error
		+Stop(): error
	}
}


package "service" {
	class "preconnectedListener" as service.preconnectedListener <<E,#FFCC00>> {
		-accepted: bool
		-conn: net.Conn
		-closech: chan struct{}
		-closeMu: sync.Mutex
		-acceptMu: sync.Mutex
		+Accept(): (net.Conn, error)
		+Close(): error
		+Addr(): net.Addr
	}
}

	service.preconnectedListener --> sync.Mutex
	service.preconnectedListener --> sync.Mutex

package "rpccommon" {
	class "RPCCallback" as rpccommon.RPCCallback <<E,#FFCC00>> {
		-s: *rpccommon.ServerImpl
		-sending: *sync.Mutex
		-codec: rpc.ServerCodec
		-req: rpc.Request
		+Return(out: interface{}, err: error)
	}
}

	rpccommon.RPCCallback --> rpccommon.ServerImpl
	rpccommon.RPCCallback --> sync.Mutex

package "rpccommon" {
	class "RPCServer" as rpccommon.RPCServer <<E,#FFCC00>> {
		-s: *rpccommon.ServerImpl
		+GetVersion(args: api.GetVersionIn, out: api.GetVersionOut): error
		+SetApiVersion(args: api.SetAPIVersionIn, out: api.SetAPIVersionOut): error
	}
}

	rpccommon.RPCServer --> rpccommon.ServerImpl

	rpccommon.RPCServer ..> api.GetVersionIn : <<use>> 
	rpccommon.RPCServer ..> api.GetVersionOut : <<use>> 
	rpccommon.RPCServer ..> api.SetAPIVersionIn : <<use>>
	rpccommon.RPCServer ..> api.SetAPIVersionOut : <<use>> 

package "rpccommon" {
	class "ServerImpl" as rpccommon.ServerImpl <<E,#FFCC00>> {
		-config: service.Config
		-listener: net.Listener
		-stopChan: chan struct{}
		-debugger: debugger.Debugger
		-s1: rpc1.RPCServer
		-s2: rpc2.RPCServer
		-methodMaps: []map[string]*rpccommon.methodType
		-log: logrus.Entry
		+Stop(): error
		+Run(): error
		-serveJSONCodec(conn: io.ReadWriteCloser)
		-sendResponse(sending: *sync.Mutex, req: rpc.Request, resp: rpc.Response, reply: interface{}, codec: rpc.ServerCodec, errmsg: string)
	}
}

	rpccommon.ServerImpl --> service.Config
	rpccommon.ServerImpl --> debugger.Debugger
	rpccommon.ServerImpl --> rpc1.RPCServer
	rpccommon.ServerImpl --> rpc2.RPCServer


package "rpccommon" {
	class "internalError" as rpccommon.internalError <<V,Orchid>> {
		+Err: interface{}
		+Stack: []rpccommon.internalErrorFrame
		+Error(): string
	}
}

	rpccommon.internalError --> rpccommon.internalErrorFrame


package "rpccommon" {
	class "internalErrorFrame" as rpccommon.internalErrorFrame <<V,Orchid>> {
		+Pc: uintptr
		+Func: string
		+File: string
		+Line: int
	}
}


package "rpccommon" {
	class "methodType" as rpccommon.methodType <<V,Orchid>> {
		-method: reflect.Method
		+Rcvr: reflect.Value
		+ArgType: reflect.Type
		+ReplyType: reflect.Type
		+Synchronous: bool
	}
}

	rpccommon.methodType --> reflect.Value
	rpccommon.methodType --> reflect.Type


package "main" {
	class "B" as main.B <<V,Orchid>> {
		+A: invalid type
	}
}



package "main" {
	class "Base" as main.Base <<V,Orchid>> {
		-y: int
		+Method(): int
	}
}



package "main" {
	class "BitFieldType" as main.BitFieldType <<V,Orchid>>
}



package "main" {
	class "Blacklist" as main.Blacklist <<V,Orchid>> {
		+String(): result: string
	}
}



package "main" {
	class "Block" as main.Block <<V,Orchid>> {
		-cache: *main.Cache
	}
}

	main.Block --> main.Cache


package "main" {
	class "C" as main.C <<V,Orchid>> {
		-s: string
	}
}



package "main" {
	class "Cache" as main.Cache <<V,Orchid>> {
		-blocks: [2000]main.Block
	}
}



package "main" {
	class "ConstType" as main.ConstType <<V,Orchid>>
}



package "main" {
	class "D" as main.D <<V,Orchid>> {
		-u1: uint32
		-u2: uint32
		-u3: uint32
		-u4: uint32
		-u5: uint32
		-u6: uint32
	}
}



package "main" {
	class "Derived" as main.Derived <<V,Orchid>> {
		-x: int
		+Base: main.Base
	}
}

	main.Derived --> main.Base


package "main" {
	class "FooBar" as main.FooBar <<V,Orchid>> {
		+Baz: int
		+Bur: string
	}
}



package "main" {
	class "FooBar2" as main.FooBar2 <<V,Orchid>> {
		+Bur: int
		+Baz: string
	}
}



package "main" {
	interface "Iface" as main.Iface {
		+NonPtrReceiver(): string
		+PtrReceiver(): string
	}
}



package "main" {
	class "Item" as main.Item <<V,Orchid>> {
		+Name: string
		+Route: string
		+Active: int
	}
}



package "main" {
	class "List" as main.List <<V,Orchid>> {
		+N: int
		+Next: *main.List
	}
}

	main.List --> main.List


package "main" {
	class "Menu" as main.Menu <<V,Orchid>>
}


main.Menu *-- main.Item
package "main" {
	class "Nest" as main.Nest <<V,Orchid>> {
		+Level: int
		+Nest: *main.Nest
	}
}

	main.Nest --> main.Nest


package "main" {
	class "Node" as main.Node <<V,Orchid>> {
		+Disable: bool
		+IP: string
		+Include: []string
		+Exclude: []string
		+Source: main.Source
		+ItemCheck(): int
	}
}

	main.Node --> main.Source


package "main" {
	class "Opcode" as main.Opcode <<V,Orchid>> {
		+Name: string
		+Code: string
		+Args: string
		+Func: string
	}
}



package "main" {
	class "OtherType" as main.OtherType <<V,Orchid>> {
		+String(): string
	}
}



package "main" {
	interface "PRcvrable" as main.PRcvrable {
		+PRcvr(: int): string
	}
}



package "main" {
	class "SomeType" as main.SomeType <<E,#FFCC00>> {
		+String(): string
		+SomeFunction()
	}
}



package "main" {
	class "Source" as main.Source <<V,Orchid>>
}



package "main" {
	class "Src" as main.Src <<V,Orchid>> {
		+Disable: bool
		+Desc: string
		+Prfx: string
		+URL: string
	}
}



package "main" {
	class "T" as main.T <<V,Orchid>> {
		-m()
	}
}



package "main" {
	interface "VRcvrable" as main.VRcvrable {
		+VRcvr(: int): string
	}
}



package "main" {
	class "W" as main.W <<V,Orchid>> {
		-x: int
		-y: int
	}
}



package "main" {
	class "X" as main.X <<V,Orchid>> {
		+CallMe()
	}
}



package "main" {
	class "X2" as main.X2 <<V,Orchid>> {
		+CallMe(i: int): int
	}
}



package "main" {
	class "a" as main.a <<V,Orchid>> {
		-aas: []main.a
	}
}

	main.a --> main.a


package "main" {
	class "a2struct" as main.a2struct <<V,Orchid>> {
		+Y: int
	}
}



package "main" {
	class "arguments" as main.arguments <<V,Orchid>> {
		+GoVersions: []main.goVersion
	}
}

	main.arguments --> main.goVersion


package "main" {
	class "asomething" as main.asomething <<V,Orchid>> {
		-n: int
		+Callback(n: int): int
		+String(): string
	}
}



package "main" {
	class "asomethingelse" as main.asomethingelse <<V,Orchid>> {
		-x: float64
		-y: float64
		+Callback2(n: int, m: int): float64
	}
}



package "main" {
	class "astruct" as main.astruct <<V,Orchid>> {
		+X: int
		+VRcvr(x: int): string
		+PRcvr(x: int): string
		+Error(): string
		+NonPointerRecieverMethod()
	}
}



package "main" {
	class "benchstruct" as main.benchstruct <<V,Orchid>> {
		-a: [64]byte
		-b: [64]byte
	}
}



package "main" {
	class "binding" as main.binding <<V,Orchid>> {
		-name: string
		-fn: types.Func
		-argType: string
		-retType: string
		-argNames: []string
		-argTypes: []string
	}
}



package "main" {
	class "bstruct" as main.bstruct <<V,Orchid>> {
		-a: main.astruct
		+Error(): string
	}
}

	main.bstruct --> main.astruct


package "main" {
	class "cstruct" as main.cstruct <<V,Orchid>> {
		-pb: *main.bstruct
		-sa: []*main.astruct
	}
}

	main.cstruct --> main.bstruct


package "main" {
	class "dstruct" as main.dstruct <<V,Orchid>> {
		-x: interface{}
	}
}



package "main" {
	class "functype" as main.functype <<V,Orchid>> {
		-functype(: int): int
	}
}



package "main" {
	class "goVersion" as main.goVersion <<V,Orchid>> {
		+Major: int
		+Minor: int
		-dec(): main.goVersion
		+MaxVersion(): bool
		+DotX(): string
		+String(): string
	}
}



package "main" {
	class "maptype" as main.maptype <<V,Orchid>>
}



package "main" {
	class "someStruct" as main.someStruct <<E,#FFCC00>> {
		-s: string
		-structfunc(s2: string)
	}
}



package "main" {
	class "truncatedMap" as main.truncatedMap <<V,Orchid>> {
		-v: []map[string]main.astruct
	}
}



package "unsafeheader" {
	class "Slice" as unsafeheader.Slice <<V,Orchid>> {
		+Data: unsafe.Pointer
		+Len: int
		+Cap: int
	}
}



package "unsafeheader" {
	class "String" as unsafeheader.String <<V,Orchid>> {
		+Data: unsafe.Pointer
		+Len: int
	}
}



package "ioio" {
	class "SomeOtherType" as ioio.SomeOtherType <<V,Orchid>> {
		+Y: int
	}
}



package "locspec" {
	class "AddrLocationSpec" as locspec.AddrLocationSpec <<V,Orchid>> {
		+AddrExpr: string
		+Find(t: proc.Target, _: []string, scope: proc.EvalScope, locStr: string, includeNonExecutableLines: bool, _: [][2]string): (api.Location, error)
	}
}


	locspec.AddrLocationSpec ..> proc.Target : <<use>> 
	locspec.AddrLocationSpec ..> proc.EvalScope : <<use>> 
	locspec.AddrLocationSpec ..> api.Location : <<return>> 
	locspec.AddrLocationSpec ..> error : <<return>> 

package "locspec" {
	class "AmbiguousLocationError" as locspec.AmbiguousLocationError <<V,Orchid>> {
		+Location: string
		+CandidatesString: []string
		+CandidatesLocation: api.Location
		+Error(): string
	}
}

	locspec.AmbiguousLocationError --> api.Location


package "locspec" {
	class "FuncLocationSpec" as locspec.FuncLocationSpec <<V,Orchid>> {
		+PackageName: string
		+AbsolutePackage: bool
		+ReceiverName: string
		+PackageOrReceiverName: string
		+BaseName: string
		+Match(sym: proc.Function, packageMap: map[string][]string): bool
	}
}


	locspec.FuncLocationSpec ..> proc.Function : <<use>> 

package "locspec" {
	class "LineLocationSpec" as locspec.LineLocationSpec <<V,Orchid>> {
		+Line: int
		+Find(t: proc.Target, _: []string, scope: proc.EvalScope, _: string, includeNonExecutableLines: bool, _: [][2]string): (api.Location, error)
	}
}


	locspec.LineLocationSpec ..> proc.Target : <<use>> 
	locspec.LineLocationSpec ..> proc.EvalScope : <<use>> 
	locspec.LineLocationSpec ..> api.Location : <<return>> 
	locspec.LineLocationSpec ..> error : <<return>> 

package "locspec" {
	interface "LocationSpec" as locspec.LocationSpec {
		+Find(t: proc.Target, processArgs: []string, scope: proc.EvalScope, locStr: string, includeNonExecutableLines: bool, substitutePathRules: [][2]string): (api.Location, error)
	}
}


	locspec.LocationSpec ..> proc.Target : <<use>> 
	locspec.LocationSpec ..> proc.EvalScope : <<use>> 
	locspec.LocationSpec ..> api.Location : <<return>> 
	locspec.LocationSpec ..> error : <<return>> 

package "locspec" {
	class "NormalLocationSpec" as locspec.NormalLocationSpec <<V,Orchid>> {
		+Base: string
		+FuncBase: *locspec.FuncLocationSpec
		+LineOffset: int
		+FileMatch(path: string): bool
		+Find(t: proc.Target, processArgs: []string, scope: proc.EvalScope, locStr: string, includeNonExecutableLines: bool, substitutePathRules: [][2]string): (api.Location, error)
	}
}

	locspec.NormalLocationSpec --> locspec.FuncLocationSpec

	locspec.NormalLocationSpec ..> proc.Target : <<use>> 
	locspec.NormalLocationSpec ..> proc.EvalScope : <<use>> 
	locspec.NormalLocationSpec ..> api.Location : <<return>> 
	locspec.NormalLocationSpec ..> error : <<return>> 

package "locspec" {
	class "OffsetLocationSpec" as locspec.OffsetLocationSpec <<V,Orchid>> {
		+Offset: int
		+Find(t: proc.Target, _: []string, scope: proc.EvalScope, _: string, includeNonExecutableLines: bool, _: [][2]string): (api.Location, error)
	}
}


	locspec.OffsetLocationSpec ..> proc.Target : <<use>> 
	locspec.OffsetLocationSpec ..> proc.EvalScope : <<use>> 
	locspec.OffsetLocationSpec ..> api.Location : <<return>> 

package "locspec" {
	class "RegexLocationSpec" as locspec.RegexLocationSpec <<V,Orchid>> {
		+FuncRegex: string
		+Find(t: proc.Target, _: []string, scope: proc.EvalScope, locStr: string, includeNonExecutableLines: bool, _: [][2]string): (api.Location, error)
	}
}


	locspec.RegexLocationSpec ..> proc.Target : <<use>> 
	locspec.RegexLocationSpec ..> proc.EvalScope : <<use>> 
	locspec.RegexLocationSpec ..> api.Location : <<return>> 


package "native" {
	class "Regs" as native.Regs <<V,Orchid>> {
		-rax: uint64
		-rbx: uint64
		-rcx: uint64
		...
		+GAddr(): (uint64, bool)
		+Get(n: int): (uint64, error)
		+Copy(): (proc.Registers, error)
	}
}

	native.Regs --> proc.Register

package "native" {
	class "_CLIENT_ID" as native._CLIENT_ID <<V,Orchid>> {
		+UniqueProcess: invalid type
		+UniqueThread: invalid type
	}
}



package "native" {
	class "_CREATE_PROCESS_DEBUG_INFO" as native._CREATE_PROCESS_DEBUG_INFO <<V,Orchid>> {
		+File: invalid type
		+Process: invalid type
		+Thread: invalid type
		+BaseOfImage: uintptr
		+DebugInfoFileOffset: uint32
		+DebugInfoSize: uint32
		+ThreadLocalBase: uintptr
		+StartAddress: uintptr
		+ImageName: uintptr
		+Unicode: uint16
	}
}

package "native" {
	class "_CREATE_THREAD_DEBUG_INFO" as native._CREATE_THREAD_DEBUG_INFO <<V,Orchid>> {
		+Thread: invalid type
		+ThreadLocalBase: uintptr
		+StartAddress: uintptr
	}
}


package "native" {
	class "_DEBUG_EVENT" as native._DEBUG_EVENT <<V,Orchid>> {
		+DebugEventCode: uint32
		+ProcessId: uint32
		+ThreadId: uint32
		-_: uint32
		+U: [160]byte
	}
}



package "native" {
	class "_EXCEPTION_DEBUG_INFO" as native._EXCEPTION_DEBUG_INFO <<V,Orchid>> {
		+ExceptionRecord: native._EXCEPTION_RECORD
		+FirstChance: uint32
	}
}

	native._EXCEPTION_DEBUG_INFO --> native._EXCEPTION_RECORD


package "native" {
	class "_EXCEPTION_RECORD" as native._EXCEPTION_RECORD <<V,Orchid>> {
		+ExceptionCode: uint32
		+ExceptionFlags: uint32
		+ExceptionRecord: *native._EXCEPTION_RECORD
		+ExceptionAddress: uintptr
		+NumberParameters: uint32
		+ExceptionInformation: [15]uintptr
	}
}

	native._EXCEPTION_RECORD --> native._EXCEPTION_RECORD


package "native" {
	class "_EXIT_PROCESS_DEBUG_INFO" as native._EXIT_PROCESS_DEBUG_INFO <<V,Orchid>> {
		+ExitCode: uint32
	}
}



package "native" {
	class "_LOAD_DLL_DEBUG_INFO" as native._LOAD_DLL_DEBUG_INFO <<V,Orchid>> {
		+File: invalid type
		+BaseOfDll: uintptr
		+DebugInfoFileOffset: uint32
		+DebugInfoSize: uint32
		+ImageName: uintptr
		+Unicode: uint16
	}
}



package "native" {
	class "_NTSTATUS" as native._NTSTATUS <<V,Orchid>>
}



package "native" {
	class "_THREAD_BASIC_INFORMATION" as native._THREAD_BASIC_INFORMATION <<V,Orchid>> {
		+ExitStatus: native._NTSTATUS
		+TebBaseAddress: uintptr
		+ClientId: native._CLIENT_ID
		+AffinityMask: uintptr
		+Priority: int32
		+BasePriority: int32
	}
}

	native._THREAD_BASIC_INFORMATION --> native._NTSTATUS
	native._THREAD_BASIC_INFORMATION --> native._CLIENT_ID


package "native" {
	class "nativeProcess" as native.nativeProcess <<E,#FFCC00>> {
		-bi: proc.BinaryInfo
		-pid: int
		-breakpoints: proc.BreakpointMap
		-threads: map[int]*native.nativeThread
		-memthread: *native.nativeThread
		-os: *native.osProcessDetails
		-firstStart: bool
		-resumeChan: chan<- struct{}
		-ptraceChan: chan func()
		-ptraceDoneChan: chan interface{}
		-childProcess: bool
		-stopMu: sync.Mutex
		-manualStopRequested: bool
		-ctty: *os.File
		-exited: bool
		-detached: bool
		+BinInfo(): proc.BinaryInfo
		+Recorded(): (bool, string)
		+Restart(: string): (proc.Thread, error)
		+ChangeDirection(dir: proc.Direction): error
		+GetDirection(): proc.Direction
		+When(): (string, error)
		+Checkpoint(: string): (int, error)
		+Checkpoints(): (proc.Checkpoint, error)
		+ClearCheckpoint(: int): error
		+Detach(kill: bool): err: error
		+Valid(): (bool, error)
		+ResumeNotify(ch: chan<- struct{})
		+Pid(): int
		+ThreadList(): proc.Thread
		+FindThread(threadID: int): (proc.Thread, bool)
		+Memory(): proc.MemoryReadWriter
		+Breakpoints(): proc.BreakpointMap
		+RequestManualStop(): error
		+CheckAndClearManualStopRequest(): bool
		+WriteBreakpoint(addr: uint64): (string, int, proc.Function, []byte, error)
		+EraseBreakpoint(bp: proc.Breakpoint): error
		+ContinueOnce(): (proc.Thread, proc.StopReason, error)
		+FindBreakpoint(pc: uint64, adjustPC: bool): (proc.Breakpoint, bool)
		-initialize(path: string, debugInfoDirs: []string): (proc.Target, error)
		-handlePtraceFuncs()
		-execPtraceFunc(fn: func())
		-postExit()
		-writeSoftwareBreakpoint(thread: *native.nativeThread, addr: uint64): error
		-kill(): error
		-requestManualStop(): error
		-updateThreadList(): error
		-addThread(hThread: invalid type, threadID: int, attach: bool, suspendNewThreads: bool, dbgUiRemoteBreakIn: bool): (*native.nativeThread, error)
		-waitForDebugEvent(flags: native.waitForDebugEventFlags): (threadID: int, exitCode: int, err: error)
		-trapWait(pid: int): (*native.nativeThread, error)
		-wait(pid: int, options: int): (int, *invalid type, error)
		-exitGuard(err: error): error
		-resume(): error
		-stop(trapthread: *native.nativeThread): (*native.nativeThread, error)
		-detach(kill: bool): error
		+EntryPoint(): (uint64, error)
		-trapWaitInternal(pid: int, halt: bool): (*native.nativeThread, error)
		-waitFast(pid: int): (int, unix.WaitStatus, error)
		-updateThreadListForTask(task: invalid type): error
		-waitForStop(): ([]int, error)
		-loadProcessInformation(wg: *sync.WaitGroup)
	}
}

	native.nativeProcess --> proc.BinaryInfo
	native.nativeProcess --> proc.BreakpointMap
	native.nativeProcess --> native.nativeThread
	native.nativeProcess --> native.osProcessDetails

	native.nativeProcess ..> proc.Thread : <<return>>
	native.nativeProcess ..> proc.Direction
	native.nativeProcess ..> proc.Checkpoint : <<return>>
	native.nativeProcess ..> proc.MemoryReadWriter : <<return>>
	native.nativeProcess ..> proc.Function : <<return>>
	native.nativeProcess ..> proc.Breakpoint
	native.nativeProcess ..> proc.StopReason : <<return>>

package "native" {
	class "nativeThread" as native.nativeThread <<E,#FFCC00>> {
		+ID: int
		+Status: *native.waitStatus
		+CurrentBreakpoint: proc.BreakpointState
		-dbp: *native.nativeProcess
		-singleStepping: bool
		-os: *native.osSpecificDetails
		-common: proc.CommonThread
		-stop(): err: error
		+Stopped(): bool
		-resume(): error
		-resumeWithSig(sig: int): err: error
		-singleStep(): err: error
		+WriteMemory(addr: uint64, data: []byte): (written: int, err: error)
		+ReadMemory(data: []byte, addr: uint64): (n: int, err: error)
		-fpRegisters(): (proc.Register, []byte, error)
		-restoreRegisters(savedRegs: proc.Registers): error
		+SetPC(pc: uint64): error
		+SetSP(sp: uint64): error
		+SetDX(dx: uint64): error
		+Continue(): error
		+StepInstruction(): err: error
		+Location(): (proc.Location, error)
		+BinInfo(): proc.BinaryInfo
		+Common(): proc.CommonThread
		+SetCurrentBreakpoint(adjustPC: bool): error
		+Breakpoint(): proc.BreakpointState
		+ThreadID(): int
		+ClearBreakpoint(bp: proc.Breakpoint): error
		+Registers(): (proc.Registers, error)
		+RestoreRegisters(savedRegs: proc.Registers): error
		+PC(): (uint64, error)
		+ProcessMemory(): proc.MemoryReadWriter
	}
}

	native.nativeThread --> native.waitStatus
	native.nativeThread --> proc.BreakpointState
	native.nativeThread --> native.nativeProcess
	native.nativeThread --> native.osSpecificDetails
	native.nativeThread --> proc.CommonThread

	native.nativeThread ..> proc.Location : <<return>>
	native.nativeThread ..> proc.BinaryInfo : <<return>>
	native.nativeThread ..> proc.Breakpoint : <<use>>
	native.nativeThread ..> proc.Registers
	native.nativeThread ..> proc.MemoryReadWriter : <<return>>

package "native" {
	class "osProcessDetails" as native.osProcessDetails <<V,Orchid>> {
		-hProcess: invalid type
		-breakThread: int
		-entryPoint: uint64
		-running: bool
	}
}



package "native" {
	class "osSpecificDetails" as native.osSpecificDetails <<V,Orchid>> {
		-delayedSignal: int
		-registers: invalid type
		-running: bool
		-setbp: bool
	}
}



package "native" {
	class "trapWaitOptions" as native.trapWaitOptions <<V,Orchid>>
}



package "native" {
	class "waitForDebugEventFlags" as native.waitForDebugEventFlags <<V,Orchid>>
}



package "native" {
	class "waitStatus" as native.waitStatus <<V,Orchid>>
}



package "unix" {
	class "BlkpgIoctlArg" as unix.BlkpgIoctlArg <<V,Orchid>> {
		+Op: int32
		+Flags: int32
		+Datalen: int32
		+Data: *byte
	}
}



package "unix" {
	class "BlkpgPartition" as unix.BlkpgPartition <<V,Orchid>> {
		+Start: int64
		+Length: int64
		+Pno: int32
		+Devname: [64]uint8
		+Volname: [64]uint8
	}
}



package "unix" {
	class "BpfHdr" as unix.BpfHdr <<V,Orchid>> {
		+Tstamp: unix.BpfTimeval
		+Caplen: uint32
		+Datalen: uint32
		+Hdrlen: uint16
		+Pad_cgo_0: [2]byte
	}
}

	unix.BpfHdr --> unix.BpfTimeval


package "unix" {
	class "BpfInsn" as unix.BpfInsn <<V,Orchid>> {
		+Code: uint16
		+Jt: uint8
		+Jf: uint8
		+K: uint32
	}
}



package "unix" {
	class "BpfProgram" as unix.BpfProgram <<V,Orchid>> {
		+Len: uint32
		+Insns: *unix.BpfInsn
	}
}

	unix.BpfProgram --> unix.BpfInsn


package "unix" {
	class "BpfStat" as unix.BpfStat <<V,Orchid>> {
		+Recv: uint32
		+Drop: uint32
	}
}



package "unix" {
	class "BpfTimeval" as unix.BpfTimeval <<V,Orchid>> {
		+Sec: uint32
		+Usec: uint32
	}
}



package "unix" {
	class "BpfVersion" as unix.BpfVersion <<V,Orchid>> {
		+Major: uint16
		+Minor: uint16
	}
}



package "unix" {
	class "BpfZbuf" as unix.BpfZbuf <<V,Orchid>> {
		+Bufa: *byte
		+Bufb: *byte
		+Buflen: uint32
	}
}



package "unix" {
	class "BpfZbufHeader" as unix.BpfZbufHeader <<V,Orchid>> {
		+Kernel_gen: uint32
		+Kernel_len: uint32
		+User_gen: uint32
		-_: [5]uint32
	}
}



package "unix" {
	class "CGroupStats" as unix.CGroupStats <<V,Orchid>> {
		+Sleeping: uint64
		+Running: uint64
		+Stopped: uint64
		+Uninterruptible: uint64
		+Io_wait: uint64
	}
}



package "unix" {
	class "CPUSet" as unix.CPUSet <<E,#FFCC00>> {
		+Zero()
		+Set(cpu: int)
		+Clear(cpu: int)
		+IsSet(cpu: int): bool
		+Count(): int
	}
}



package "unix" {
	class "CanFilter" as unix.CanFilter <<V,Orchid>> {
		+Id: uint32
		+Mask: uint32
	}
}



package "unix" {
	class "CapRights" as unix.CapRights <<V,Orchid>> {
		+Rights: [2]uint64
	}
}



package "unix" {
	class "CapUserData" as unix.CapUserData <<V,Orchid>> {
		+Effective: uint32
		+Permitted: uint32
		+Inheritable: uint32
	}
}



package "unix" {
	class "CapUserHeader" as unix.CapUserHeader <<V,Orchid>> {
		+Version: uint32
		+Pid: int32
	}
}



package "unix" {
	class "Clockinfo" as unix.Clockinfo <<V,Orchid>> {
		+Hz: int32
		+Tick: int32
		+Tickadj: int32
		+Stathz: int32
		+Profhz: int32
	}
}



package "unix" {
	class "Cmsghdr" as unix.Cmsghdr <<E,#FFCC00>> {
		+Len: uint32
		+Level: int32
		+Type: int32
		+SetLen(length: int)
		-data(offset: uintptr): unsafe.Pointer
	}
}



package "unix" {
	class "CryptoReportAEAD" as unix.CryptoReportAEAD <<V,Orchid>> {
		+Type: [64]int8
		+Geniv: [64]int8
		+Blocksize: uint32
		+Maxauthsize: uint32
		+Ivsize: uint32
	}
}



package "unix" {
	class "Dirent" as unix.Dirent <<V,Orchid>> {
		+Fileno: uint64
		+Off: int64
		+Reclen: uint16
		+Type: uint8
		+Namlen: uint8
		+X__d_padding: [4]uint8
		+Name: [256]int8
	}
}



package "unix" {
	class "EpollEvent" as unix.EpollEvent <<V,Orchid>> {
		+Events: uint32
		+Fd: int32
		+Pad: int32
	}
}



package "syscall" {
	class "Errno" as syscall.Errno <<V,Orchid>> {
		+Error(): string
		+Is(target: error): bool
		+Temporary(): bool
		+Timeout(): bool
	}
}


	syscall.Errno ..> error : <<use>> 

package "unix" {
	class "FanotifyEventMetadata" as unix.FanotifyEventMetadata <<V,Orchid>> {
		+Event_len: uint32
		+Vers: uint8
		+Reserved: uint8
		+Metadata_len: uint16
		+Mask: uint64
		+Fd: int32
		+Pid: int32
	}
}



package "unix" {
	class "FanotifyResponse" as unix.FanotifyResponse <<V,Orchid>> {
		+Fd: int32
		+Response: uint32
	}
}



package "unix" {
	class "Fbootstraptransfer_t" as unix.Fbootstraptransfer_t <<V,Orchid>> {
		+Offset: int64
		+Length: uint32
		+Buffer: *byte
	}
}



package "unix" {
	class "FdSet" as unix.FdSet <<E,#FFCC00>> {
		+Bits: [32]uint32
		+Set(fd: int)
		+Clear(fd: int)
		+IsSet(fd: int): bool
		+Zero()
	}
}



package "unix" {
	class "FileHandle" as unix.FileHandle <<V,Orchid>> {
		-fileHandle: *unix.fileHandle
		+Size(): int
		+Type(): int32
		+Bytes(): []byte
	}
}

	unix.FileHandle --> unix.fileHandle


package "unix" {
	class "Flock_t" as unix.Flock_t <<V,Orchid>> {
		+Start: int64
		+Len: int64
		+Pid: int32
		+Type: int16
		+Whence: int16
	}
}



package "unix" {
	class "FpReg" as unix.FpReg <<V,Orchid>> {
		+Fpr_fpsr: uint32
		+Fpr: [8][3]uint32
	}
}



package "unix" {
	class "FscryptAddKeyArg" as unix.FscryptAddKeyArg <<V,Orchid>> {
		+Key_spec: unix.FscryptKeySpecifier
		+Raw_size: uint32
		+Key_id: uint32
		-_: [8]uint32
	}
}

	unix.FscryptAddKeyArg --> unix.FscryptKeySpecifier



package "unix" {
	class "PtraceFpregs" as unix.PtraceFpregs <<V,Orchid>> {
		+Fpc: uint32
		+Fprs: [16]float64
	}
}



package "unix" {
	class "PtraceIoDesc" as unix.PtraceIoDesc <<V,Orchid>> {
		+Op: int32
		+Offs: *byte
		+Addr: *byte
		+Len: uint32
	}
}



package "unix" {
	class "PtraceLwpInfoStruct" as unix.PtraceLwpInfoStruct <<V,Orchid>> {
		+Lwpid: int32
		+Event: int32
		+Flags: int32
		+Sigmask: unix.Sigset_t
		+Siglist: unix.Sigset_t
		+Siginfo: unix.__Siginfo
		+Tdname: [20]int8
		+Child_pid: int32
		+Syscall_code: uint32
		+Syscall_narg: uint32
	}
}

	unix.PtraceLwpInfoStruct --> unix.Sigset_t
	unix.PtraceLwpInfoStruct --> unix.__Siginfo


package "unix" {
	class "PtracePer" as unix.PtracePer <<V,Orchid>> {
		-_: [0]uint64
		-_: [32]byte
		+Starting_addr: uint64
		+Ending_addr: uint64
		+Perc_atmid: uint16
		+Address: uint64
		+Access_id: uint8
		-_: [7]byte
	}
}



package "unix" {
	class "PtracePsw" as unix.PtracePsw <<V,Orchid>> {
		+Mask: uint64
		+Addr: uint64
	}
}



package "unix" {
	class "PtraceRegs" as unix.PtraceRegs <<E,#FFCC00>> {
		+Ebx: int32
		+Ecx: int32
		+Edx: int32
		...
	}
}



package "unix" {
	class "PtraceRegs386" as unix.PtraceRegs386 <<V,Orchid>> {
		+Ebx: int32
		+Ecx: int32
		+Edx: int32
		...
	}
}



package "unix" {
	class "PtraceRegsAmd64" as unix.PtraceRegsAmd64 <<V,Orchid>> {
		+R15: uint64
		+R14: uint64
		+R13: uint64
		...
	}
}


package "unix" {
	class "RTCPLLInfo" as unix.RTCPLLInfo <<V,Orchid>> {
		+Ctrl: int32
		+Value: int32
		+Max: int32
		+Min: int32
		+Posmult: int32
		+Negmult: int32
		+Clock: int32
	}
}


package "unix" {
	class "RTCTime" as unix.RTCTime <<V,Orchid>> {
		+Sec: int32
		+Min: int32
		+Hour: int32
		+Mday: int32
		+Mon: int32
		+Year: int32
		+Wday: int32
		+Yday: int32
		+Isdst: int32
	}
}



package "unix" {
	class "RTCWkAlrm" as unix.RTCWkAlrm <<V,Orchid>> {
		+Enabled: uint8
		+Pending: uint8
		+Time: unix.RTCTime
	}
}

	unix.RTCWkAlrm --> unix.RTCTime

package "unix" {
	class "Reg" as unix.Reg <<V,Orchid>> {
		+R: [13]uint32
		+R_sp: uint32
		+R_lr: uint32
		+R_pc: uint32
		+R_cpsr: uint32
	}
}


package "syscall" {
	class "SysProcAttr" as syscall.SysProcAttr <<V,Orchid>> {
		+Chroot: string
		+Credential: *syscall.Credential
		+Ptrace: bool
		+Setsid: bool
		+Setpgid: bool
		+Setctty: bool
		+Noctty: bool
		+Ctty: int
		+Foreground: bool
		+Pgid: int
	}
}

package "unix" {
	class "WaitStatus" as unix.WaitStatus <<V,Orchid>> {
		+Exited(): bool
		+ExitStatus(): int
		+Signaled(): bool
		+Signal(): syscall.Signal
		+CoreDump(): bool
		+Stopped(): bool
		+Continued(): bool
		+StopSignal(): syscall.Signal
		+TrapCause(): int
		+Killed(): bool
	}
}

	unix.WaitStatus ..> syscall.Signal : <<return>>

package "unix" {
	class "syscallFunc" as unix.syscallFunc <<V,Orchid>>
}


package "godwarf" {
	class "AddrType" as godwarf.AddrType <<V,Orchid>> {
		+BasicType: godwarf.BasicType
	}
}

	godwarf.AddrType --> godwarf.BasicType


package "godwarf" {
	class "ArrayType" as godwarf.ArrayType <<V,Orchid>> {
		+CommonType: godwarf.CommonType
		+Type: godwarf.Type
		+StrideBitSize: int64
		+Count: int64
		+String(): string
		-stringIntl(recCheck: godwarf.recCheck): string
		+Size(): int64
		+Align(): int64
		-sizeAlignIntl(recCheck: godwarf.recCheck): (int64, int64)
	}
}

	godwarf.ArrayType --> godwarf.CommonType
	godwarf.ArrayType --> godwarf.Type


package "godwarf" {
	class "BasicType" as godwarf.BasicType <<V,Orchid>> {
		+CommonType: godwarf.CommonType
		+BitSize: int64
		+BitOffset: int64
		+Basic(): *godwarf.BasicType
		+String(): string
		-stringIntl(: godwarf.recCheck): string
		+Align(): int64
	}
}

	godwarf.BasicType --> godwarf.CommonType
	godwarf.BasicType ..> godwarf.BasicType : <<return>>

package "godwarf" {
	class "BoolType" as godwarf.BoolType <<V,Orchid>> {
		+BasicType: godwarf.BasicType
	}
}

	godwarf.BoolType --> godwarf.BasicType


package "godwarf" {
	class "ChanType" as godwarf.ChanType <<V,Orchid>> {
		+TypedefType: godwarf.TypedefType
		+ElemType: godwarf.Type
		+String(): string
		-stringIntl(recCheck: godwarf.recCheck): string
	}
}

	godwarf.ChanType --> godwarf.TypedefType
	godwarf.ChanType --> godwarf.Type


package "godwarf" {
	class "CharType" as godwarf.CharType <<V,Orchid>> {
		+BasicType: godwarf.BasicType
	}
}

	godwarf.CharType --> godwarf.BasicType


package "godwarf" {
	class "CommonType" as godwarf.CommonType <<V,Orchid>> {
		+Index: int
		+ByteSize: int64
		+Name: string
		+ReflectKind: reflect.Kind
		+Offset: dwarf.Offset
		+Common(): *godwarf.CommonType
		+Size(): int64
		+Align(): int64
		-sizeAlignIntl(: godwarf.recCheck): (int64, int64)
	}
}

	godwarf.CommonType ..> godwarf.CommonType : <<return>>

package "godwarf" {
	class "ComplexType" as godwarf.ComplexType <<V,Orchid>> {
		+BasicType: godwarf.BasicType
	}
}

	godwarf.ComplexType --> godwarf.BasicType


package "godwarf" {
	class "DebugAddr" as godwarf.DebugAddr <<V,Orchid>> {
		+DebugAddrSection: *godwarf.DebugAddrSection
		-addrBase: uint64
		+Get(idx: uint64): (uint64, error)
	}
}

	godwarf.DebugAddr --> godwarf.DebugAddrSection

	godwarf.DebugAddr ..> error : <<return>> 

package "godwarf" {
	class "DebugAddrSection" as godwarf.DebugAddrSection <<V,Orchid>> {
		-byteOrder: binary.ByteOrder
		-ptrSz: int
		-data: []byte
		+GetSubsection(addrBase: uint64): *godwarf.DebugAddr
	}
}

	godwarf.DebugAddrSection ..> godwarf.DebugAddr : <<return>>

package "godwarf" {
	class "DotDotDotType" as godwarf.DotDotDotType <<V,Orchid>> {
		+CommonType: godwarf.CommonType
		+String(): string
		-stringIntl(recCheck: godwarf.recCheck): string
	}
}

	godwarf.DotDotDotType --> godwarf.CommonType


package "godwarf" {
	interface "Entry" as godwarf.Entry {
		+Val(: dwarf.Attr): interface{}
	}
}


	godwarf.Entry ..> dwarf.Attr : <<use>> 

package "godwarf" {
	class "EnumType" as godwarf.EnumType <<V,Orchid>> {
		+CommonType: godwarf.CommonType
		+EnumName: string
		+Val: []*godwarf.EnumValue
		+String(): string
		-stringIntl(recCheck: godwarf.recCheck): string
	}
}

	godwarf.EnumType --> godwarf.CommonType


package "godwarf" {
	class "EnumValue" as godwarf.EnumValue <<V,Orchid>> {
		+Name: string
		+Val: int64
	}
}


package "godwarf" {
	class "FloatType" as godwarf.FloatType <<V,Orchid>> {
		+BasicType: godwarf.BasicType
	}
}

	godwarf.FloatType --> godwarf.BasicType


package "godwarf" {
	class "FuncType" as godwarf.FuncType <<V,Orchid>> {
		+CommonType: godwarf.CommonType
		+ReturnType: godwarf.Type
		+ParamType: []godwarf.Type
		+String(): string
		-stringIntl(recCheck: godwarf.recCheck): string
	}
}

	godwarf.FuncType --> godwarf.CommonType
	godwarf.FuncType --> godwarf.Type


package "godwarf" {
	class "IntType" as godwarf.IntType <<V,Orchid>> {
		+BasicType: godwarf.BasicType
	}
}

	godwarf.IntType --> godwarf.BasicType


package "godwarf" {
	class "InterfaceType" as godwarf.InterfaceType <<V,Orchid>> {
		+TypedefType: godwarf.TypedefType
		+String(): string
		-stringIntl(recCheck: godwarf.recCheck): string
	}
}

	godwarf.InterfaceType --> godwarf.TypedefType


package "godwarf" {
	class "MapType" as godwarf.MapType <<V,Orchid>> {
		+TypedefType: godwarf.TypedefType
		+KeyType: godwarf.Type
		+ElemType: godwarf.Type
		+String(): string
		-stringIntl(recCheck: godwarf.recCheck): string
	}
}

	godwarf.MapType --> godwarf.TypedefType
	godwarf.MapType --> godwarf.Type


package "godwarf" {
	class "PtrType" as godwarf.PtrType <<V,Orchid>> {
		+CommonType: godwarf.CommonType
		+Type: godwarf.Type
		+String(): string
		-stringIntl(recCheck: godwarf.recCheck): string
	}
}

	godwarf.PtrType --> godwarf.CommonType
	godwarf.PtrType --> godwarf.Type


package "godwarf" {
	class "QualType" as godwarf.QualType <<V,Orchid>> {
		+CommonType: godwarf.CommonType
		+Qual: string
		+Type: godwarf.Type
		+String(): string
		-stringIntl(recCheck: godwarf.recCheck): string
		+Size(): int64
		-sizeAlignIntl(recCheck: godwarf.recCheck): (int64, int64)
	}
}

	godwarf.QualType --> godwarf.CommonType
	godwarf.QualType --> godwarf.Type


package "godwarf" {
	class "SliceType" as godwarf.SliceType <<V,Orchid>> {
		+StructType: godwarf.StructType
		+ElemType: godwarf.Type
		+String(): string
		-stringIntl(recCheck: godwarf.recCheck): string
	}
}

	godwarf.SliceType --> godwarf.StructType
	godwarf.SliceType --> godwarf.Type


package "godwarf" {
	class "StringType" as godwarf.StringType <<V,Orchid>> {
		+StructType: godwarf.StructType
		+String(): string
		-stringIntl(recCheck: godwarf.recCheck): string
	}
}

	godwarf.StringType --> godwarf.StructType


package "godwarf" {
	class "StructField" as godwarf.StructField <<V,Orchid>> {
		+Name: string
		+Type: godwarf.Type
		+ByteOffset: int64
		+ByteSize: int64
		+BitOffset: int64
		+BitSize: int64
		+Embedded: bool
	}
}

	godwarf.StructField --> godwarf.Type


package "godwarf" {
	class "StructType" as godwarf.StructType <<V,Orchid>> {
		+CommonType: godwarf.CommonType
		+StructName: string
		+Kind: string
		+Field: []*godwarf.StructField
		+Incomplete: bool
		+String(): string
		-stringIntl(recCheck: godwarf.recCheck): string
		+Defn(recCheck: godwarf.recCheck): string
		+Size(): int64
		+Align(): int64
		-sizeAlignIntl(recCheck: godwarf.recCheck): (int64, int64)
	}
}

	godwarf.StructType --> godwarf.CommonType
	godwarf.StructType ..> godwarf.recCheck : <<use>>

package "godwarf" {
	class "Tree" as godwarf.Tree <<E,#FFCC00>> {
		+Entry: godwarf.Entry
		-typ: godwarf.Type
		+Tag: dwarf.Tag
		+Offset: dwarf.Offset
		+Ranges: [][2]uint64
		+Children: []*godwarf.Tree
		-resolveRanges(dw: dwarf.Data, staticBase: uint64): error
		-resolveAbstractEntries(rdr: dwarf.Reader)
		+ContainsPC(pc: uint64): bool
		+Type(dw: dwarf.Data, index: int, typeCache: dwarf.Offset]godwarf.Type): (godwarf.Type, error)
	}
}

	godwarf.Tree --> godwarf.Entry
	godwarf.Tree --> godwarf.Type

package "godwarf" {
	interface "Type" as godwarf.Type {
		+Align(): int64
		+Common(): *godwarf.CommonType
		+Size(): int64
		+String(): string
		-sizeAlignIntl(: godwarf.recCheck): (int64, int64)
		-stringIntl(: godwarf.recCheck): string
	}
}

	godwarf.Type ..> godwarf.CommonType : <<return>>

package "godwarf" {
	class "TypedefType" as godwarf.TypedefType <<V,Orchid>> {
		+CommonType: godwarf.CommonType
		+Type: godwarf.Type
		+String(): string
		-stringIntl(recCheck: godwarf.recCheck): string
		+Size(): int64
		-sizeAlignIntl(recCheck: godwarf.recCheck): (int64, int64)
	}
}

	godwarf.TypedefType --> godwarf.CommonType
	godwarf.TypedefType --> godwarf.Type


package "godwarf" {
	class "UcharType" as godwarf.UcharType <<V,Orchid>> {
		+BasicType: godwarf.BasicType
	}
}

	godwarf.UcharType --> godwarf.BasicType


package "godwarf" {
	class "UintType" as godwarf.UintType <<V,Orchid>> {
		+BasicType: godwarf.BasicType
	}
}

	godwarf.UintType --> godwarf.BasicType


package "godwarf" {
	class "UnspecifiedType" as godwarf.UnspecifiedType <<V,Orchid>> {
		+BasicType: godwarf.BasicType
	}
}

	godwarf.UnspecifiedType --> godwarf.BasicType


package "godwarf" {
	class "UnsupportedType" as godwarf.UnsupportedType <<V,Orchid>> {
		+CommonType: godwarf.CommonType
		+Tag: dwarf.Tag
		-stringIntl(: godwarf.recCheck): string
		+String(): string
	}
}

	godwarf.UnsupportedType --> godwarf.CommonType


package "godwarf" {
	class "VoidType" as godwarf.VoidType <<V,Orchid>> {
		+CommonType: godwarf.CommonType
		+String(): string
		-stringIntl(: godwarf.recCheck): string
	}
}

	godwarf.VoidType --> godwarf.CommonType


package "godwarf" {
	class "compositeEntry" as godwarf.compositeEntry <<V,Orchid>> {
		+Val(attr: dwarf.Attr): interface{}
	}
}


	godwarf.compositeEntry ..> dwarf.Attr : <<use>> 

package "godwarf" {
	class "delayedSize" as godwarf.delayedSize <<V,Orchid>> {
		-ct: *godwarf.CommonType
		-ut: godwarf.Type
	}
}

	godwarf.delayedSize --> godwarf.CommonType
	godwarf.delayedSize --> godwarf.Type


package "godwarf" {
	class "recCheck" as godwarf.recCheck <<V,Orchid>> {
		-acquire(off: dwarf.Offset): release: func()
	}
}




package "rpc1" {
	class "DisassembleRequest" as rpc1.DisassembleRequest <<V,Orchid>> {
		+Scope: api.EvalScope
		+StartPC: uint64
		+EndPC: uint64
		+Flavour: api.AssemblyFlavour
	}
}

	rpc1.DisassembleRequest --> api.EvalScope
	rpc1.DisassembleRequest --> api.AssemblyFlavour


package "rpc1" {
	class "EvalSymbolArgs" as rpc1.EvalSymbolArgs <<V,Orchid>> {
		+Scope: api.EvalScope
		+Symbol: string
	}
}

	rpc1.EvalSymbolArgs --> api.EvalScope


package "rpc1" {
	class "FindLocationArgs" as rpc1.FindLocationArgs <<V,Orchid>> {
		+Scope: api.EvalScope
		+Loc: string
	}
}

	rpc1.FindLocationArgs --> api.EvalScope


package "rpc1" {
	class "RPCClient" as rpc1.RPCClient <<E,#FFCC00>> {
		-addr: string
		-client: rpc.Client
		-haltMu: sync.Mutex
		-haltReq: bool
		+ProcessPid(): int
		+Detach(kill: bool): error
		+Restart(): error
		+GetState(): (api.DebuggerState, error)
		+Continue(): api.DebuggerState
		+Next(): (api.DebuggerState, error)
		+Step(): (api.DebuggerState, error)
		+Call(expr: string): (api.DebuggerState, error)
		+StepInstruction(): (api.DebuggerState, error)
		+ReverseStepInstruction(): (api.DebuggerState, error)
		+SwitchThread(threadID: int): (api.DebuggerState, error)
		+SwitchGoroutine(goroutineID: int): (api.DebuggerState, error)
		+Halt(): (api.DebuggerState, error)
		+GetBreakpoint(id: int): (api.Breakpoint, error)
		+GetBreakpointByName(name: string): (api.Breakpoint, error)
		+CreateBreakpoint(breakPoint: api.Breakpoint): (api.Breakpoint, error)
		+ListBreakpoints(): (api.Breakpoint, error)
		+ClearBreakpoint(id: int): (api.Breakpoint, error)
		+ClearBreakpointByName(name: string): (api.Breakpoint, error)
		+AmendBreakpoint(bp: api.Breakpoint): error
		+CancelNext(): error
		+ListThreads(): (api.Thread, error)
		+GetThread(id: int): (api.Thread, error)
		+EvalVariable(scope: api.EvalScope, symbol: string): (api.Variable, error)
		+SetVariable(scope: api.EvalScope, symbol: string, value: string): error
		+ListSources(filter: string): ([]string, error)
		+ListFunctions(filter: string): ([]string, error)
		+ListTypes(filter: string): ([]string, error)
		+ListPackageVariables(filter: string): (api.Variable, error)
		+ListPackageVariablesFor(threadID: int, filter: string): (api.Variable, error)
		+ListLocalVariables(scope: api.EvalScope): (api.Variable, error)
		+ListRegisters(): (string, error)
		+ListFunctionArgs(scope: api.EvalScope): (api.Variable, error)
		+ListGoroutines(): (api.Goroutine, error)
		+Stacktrace(goroutineId: int, depth: int, full: bool): (api.Stackframe, error)
		+AttachedToExistingProcess(): bool
		+FindLocation(scope: api.EvalScope, loc: string): (api.Location, error)
		+DisassembleRange(scope: api.EvalScope, startPC: uint64, endPC: uint64, flavour: api.AssemblyFlavour): (api.AsmInstructions, error)
		+DisassemblePC(scope: api.EvalScope, pc: uint64, flavour: api.AssemblyFlavour): (api.AsmInstructions, error)
		-call(method: string, args: interface{}, reply: interface{}): error
	}
}

	rpc1.RPCClient --> sync.Mutex

	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.DebuggerState : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.DebuggerState : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.DebuggerState : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.DebuggerState : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.DebuggerState : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.DebuggerState : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.DebuggerState : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.DebuggerState : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.DebuggerState : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.Breakpoint : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.Breakpoint : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.Breakpoint : <<use>> 
	rpc1.RPCClient ..> api.Breakpoint : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.Breakpoint : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.Breakpoint : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.Breakpoint : <<use>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.Thread : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.EvalScope : <<use>> 
	rpc1.RPCClient ..> api.Variable : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.EvalScope : <<use>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.Variable : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.Variable : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.EvalScope : <<use>> 
	rpc1.RPCClient ..> api.Variable : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.EvalScope : <<use>> 
	rpc1.RPCClient ..> api.Variable : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.Stackframe : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.EvalScope : <<use>> 
	rpc1.RPCClient ..> api.Location : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.EvalScope : <<use>> 
	rpc1.RPCClient ..> api.AssemblyFlavour : <<use>> 
	rpc1.RPCClient ..> api.AsmInstructions : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 
	rpc1.RPCClient ..> api.EvalScope : <<use>> 
	rpc1.RPCClient ..> api.AssemblyFlavour : <<use>> 
	rpc1.RPCClient ..> api.AsmInstructions : <<return>> 
	rpc1.RPCClient ..> error : <<return>> 

package "rpc1" {
	class "RPCServer" as rpc1.RPCServer <<E,#FFCC00>> {
		-config: service.Config
		-debugger: debugger.Debugger
		+ProcessPid(arg1: interface{}, pid: *int): error
		+Detach(kill: bool, ret: *int): error
		+Restart(arg1: interface{}, arg2: *int): error
		+State(arg: interface{}, state: api.DebuggerState): error
		+Command(command: api.DebuggerCommand, cb: service.RPCCallback)
		+GetBreakpoint(id: int, breakpoint: api.Breakpoint): error
		+GetBreakpointByName(name: string, breakpoint: api.Breakpoint): error
		+StacktraceGoroutine(args: *rpc1.StacktraceGoroutineArgs, locations: api.Stackframe): error
		+ListBreakpoints(arg: interface{}, breakpoints: api.Breakpoint): error
		+CreateBreakpoint(bp: api.Breakpoint, newBreakpoint: api.Breakpoint): error
		+ClearBreakpoint(id: int, breakpoint: api.Breakpoint): error
		+ClearBreakpointByName(name: string, breakpoint: api.Breakpoint): error
		+AmendBreakpoint(amend: api.Breakpoint, unused: *int): error
		+ListThreads(arg: interface{}, threads: api.Thread): err: error
		+GetThread(id: int, thread: api.Thread): error
		+ListPackageVars(filter: string, variables: api.Variable): error
		+ListThreadPackageVars(args: *rpc1.ThreadListArgs, variables: api.Variable): error
		+ListRegisters(arg: interface{}, registers: *string): error
		+ListLocalVars(scope: api.EvalScope, variables: api.Variable): error
		+ListFunctionArgs(scope: api.EvalScope, variables: api.Variable): error
		+EvalSymbol(args: rpc1.EvalSymbolArgs, variable: api.Variable): error
		+SetSymbol(args: rpc1.SetSymbolArgs, unused: *int): error
		+ListSources(filter: string, sources: *[]string): error
		+ListFunctions(filter: string, funcs: *[]string): error
		+ListTypes(filter: string, types: *[]string): error
		+ListGoroutines(arg: interface{}, goroutines: api.Goroutine): error
		+AttachedToExistingProcess(arg: interface{}, answer: *bool): error
		+FindLocation(args: rpc1.FindLocationArgs, answer: api.Location): error
		+Disassemble(args: rpc1.DisassembleRequest, answer: api.AsmInstructions): error
	}
}

	rpc1.RPCServer --> service.Config
	rpc1.RPCServer --> debugger.Debugger

	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> api.DebuggerState : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> api.DebuggerCommand : <<use>> 
	rpc1.RPCServer ..> service.RPCCallback : <<use>> 
	rpc1.RPCServer ..> api.Breakpoint : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> api.Breakpoint : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> rpc1.StacktraceGoroutineArgs : <<use>> 
	rpc1.RPCServer ..> api.Stackframe : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> api.Breakpoint : <<use>> 
	rpc1.RPCServer ..> api.Breakpoint : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> api.Breakpoint : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> api.Breakpoint : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> api.Breakpoint : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> api.Thread : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> api.Variable : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> rpc1.ThreadListArgs : <<use>> 
	rpc1.RPCServer ..> api.Variable : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> api.EvalScope : <<use>> 
	rpc1.RPCServer ..> api.Variable : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> api.EvalScope : <<use>> 
	rpc1.RPCServer ..> api.Variable : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> rpc1.EvalSymbolArgs : <<use>> 
	rpc1.RPCServer ..> api.Variable : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> rpc1.SetSymbolArgs : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> rpc1.FindLocationArgs : <<use>> 
	rpc1.RPCServer ..> api.Location : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 
	rpc1.RPCServer ..> rpc1.DisassembleRequest : <<use>> 
	rpc1.RPCServer ..> api.AsmInstructions : <<use>> 
	rpc1.RPCServer ..> error : <<return>> 

package "rpc1" {
	class "SetSymbolArgs" as rpc1.SetSymbolArgs <<V,Orchid>> {
		+Scope: api.EvalScope
		+Symbol: string
		+Value: string
	}
}

	rpc1.SetSymbolArgs --> api.EvalScope


package "rpc1" {
	class "StacktraceGoroutineArgs" as rpc1.StacktraceGoroutineArgs <<V,Orchid>> {
		+Id: int
		+Depth: int
		+Full: bool
	}
}



package "rpc1" {
	class "ThreadListArgs" as rpc1.ThreadListArgs <<V,Orchid>> {
		+Id: int
		+Filter: string
	}
}



package "mousetrap" {
	class "processEntry32" as mousetrap.processEntry32 <<V,Orchid>> {
		-dwSize: uint32
		-cntUsage: uint32
		-th32ProcessID: uint32
		-th32DefaultHeapID: int
		-th32ModuleID: uint32
		-cntThreads: uint32
		-th32ParentProcessID: uint32
		-pcPriClassBase: int32
		-dwFlags: uint32
		-szExeFile: [-1]uint16
	}
}



package "x86asm" {
	interface "Arg" as x86asm.Arg {
		+String(): string
		-isArg()
	}
}



package "x86asm" {
	class "Args" as x86asm.Args <<V,Orchid>>
}



package "x86asm" {
	class "Imm" as x86asm.Imm <<V,Orchid>> {
		-isArg()
		+String(): string
	}
}



package "x86asm" {
	class "Inst" as x86asm.Inst <<V,Orchid>> {
		+Prefix: x86asm.Prefixes
		+Op: x86asm.Op
		+Opcode: uint32
		+Args: x86asm.Args
		+Mode: int
		+AddrSize: int
		+DataSize: int
		+MemBytes: int
		+Len: int
		+PCRel: int
		+PCRelOff: int
		+String(): string
	}
}

	x86asm.Inst --> x86asm.Prefixes
	x86asm.Inst --> x86asm.Op
	x86asm.Inst --> x86asm.Args


package "x86asm" {
	class "Mem" as x86asm.Mem <<V,Orchid>> {
		+Segment: x86asm.Reg
		+Base: x86asm.Reg
		+Scale: uint8
		+Index: x86asm.Reg
		+Disp: int64
		-isArg()
		+String(): string
	}
}

	x86asm.Mem --> x86asm.Reg
	x86asm.Mem --> x86asm.Reg
	x86asm.Mem --> x86asm.Reg


package "x86asm" {
	class "Op" as x86asm.Op <<V,Orchid>> {
		+String(): string
	}
}



package "x86asm" {
	class "Prefix" as x86asm.Prefix <<V,Orchid>> {
		+IsREX(): bool
		+IsVEX(): bool
		+String(): string
	}
}



package "x86asm" {
	class "Prefixes" as x86asm.Prefixes <<V,Orchid>>
}



package "x86asm" {
	class "Reg" as x86asm.Reg <<V,Orchid>> {
		-isArg()
		+String(): string
	}
}



package "x86asm" {
	class "Rel" as x86asm.Rel <<V,Orchid>> {
		-isArg()
		+String(): string
	}
}



package "x86asm" {
	class "SymLookup" as x86asm.SymLookup <<V,Orchid>> {
		+SymLookup(: uint64): (string, uint64)
	}
}



package "x86asm" {
	class "decodeOp" as x86asm.decodeOp <<V,Orchid>>
}

	api.Registers -up-|> proc.CpuArch
	compile.Opcode -up-|> proc.CpuArch
	core.linuxAMD64Thread -up-|> core.osThread
	core.linuxARM64Thread -up-|> core.osThread
	core.offsetReaderAt -up-|> proc.MemoryReader
	core.process -up-|> proc.MemoryReadWriter
	core.process -up-|> proc.MemoryReader
	core.process -up-|> proc.ProcessManipulation
	core.splicedMemory -up-|> proc.MemoryReader
	core.windowsAMD64Thread -up-|> core.osThread
	gcimporter.anyType -up-|> proc.CpuArch
	gcimporter.dddSlice -up-|> proc.CpuArch
	gcimporter.intWriter -up-|> proc.CpuArch
	godwarf.AddrType -up-|> godwarf.Type
	godwarf.AddrType -up-|> proc.CpuArch
	godwarf.ArrayType -up-|> godwarf.Type
	godwarf.ArrayType -up-|> proc.CpuArch
	godwarf.BasicType -up-|> godwarf.Type
	godwarf.BasicType -up-|> proc.CpuArch
	godwarf.BoolType -up-|> godwarf.Type
	godwarf.BoolType -up-|> proc.CpuArch
	godwarf.ChanType -up-|> godwarf.Type
	godwarf.ChanType -up-|> proc.CpuArch
	godwarf.CharType -up-|> godwarf.Type
	godwarf.CharType -up-|> proc.CpuArch
	godwarf.ComplexType -up-|> godwarf.Type
	godwarf.ComplexType -up-|> proc.CpuArch
	godwarf.DotDotDotType -up-|> godwarf.Type
	godwarf.DotDotDotType -up-|> proc.CpuArch
	godwarf.EnumType -up-|> godwarf.Type
	godwarf.EnumType -up-|> proc.CpuArch
	godwarf.FloatType -up-|> godwarf.Type
	godwarf.FloatType -up-|> proc.CpuArch
	godwarf.FuncType -up-|> godwarf.Type
	godwarf.FuncType -up-|> proc.CpuArch
	godwarf.IntType -up-|> godwarf.Type
	godwarf.IntType -up-|> proc.CpuArch
	godwarf.InterfaceType -up-|> godwarf.Type
	godwarf.InterfaceType -up-|> proc.CpuArch
	godwarf.MapType -up-|> godwarf.Type
	godwarf.MapType -up-|> proc.CpuArch
	godwarf.PtrType -up-|> godwarf.Type
	godwarf.PtrType -up-|> proc.CpuArch
	godwarf.QualType -up-|> godwarf.Type
	godwarf.QualType -up-|> proc.CpuArch
	godwarf.SliceType -up-|> godwarf.Type
	godwarf.SliceType -up-|> proc.CpuArch
	godwarf.StringType -up-|> godwarf.Type
	godwarf.StringType -up-|> proc.CpuArch
	godwarf.StructType -up-|> godwarf.Type
	godwarf.StructType -up-|> proc.CpuArch
	godwarf.Tree -up-|> godwarf.Entry
	godwarf.Type -up-|> proc.CpuArch
	godwarf.TypedefType -up-|> godwarf.Type
	godwarf.TypedefType -up-|> proc.CpuArch
	godwarf.UcharType -up-|> godwarf.Type
	godwarf.UcharType -up-|> proc.CpuArch
	godwarf.UintType -up-|> godwarf.Type
	godwarf.UintType -up-|> proc.CpuArch
	godwarf.UnspecifiedType -up-|> godwarf.Type
	godwarf.UnspecifiedType -up-|> proc.CpuArch
	godwarf.UnsupportedType -up-|> godwarf.Type
	godwarf.UnsupportedType -up-|> proc.CpuArch
	godwarf.VoidType -up-|> godwarf.Type
	godwarf.VoidType -up-|> proc.CpuArch
	godwarf.compositeEntry -up-|> godwarf.Entry
	liner.inputMode -up-|> liner.ModeApplier
	liner.noopMode -up-|> liner.ModeApplier
	liner.termios -up-|> liner.ModeApplier
	loclist.Dwarf2Reader -up-|> loclist.Reader
	loclist.Dwarf5Reader -up-|> loclist.Reader
	locspec.AddrLocationSpec -up-|> locspec.LocationSpec
	locspec.LineLocationSpec -up-|> locspec.LocationSpec
	locspec.NormalLocationSpec -up-|> locspec.LocationSpec
	locspec.OffsetLocationSpec -up-|> locspec.LocationSpec
	locspec.RegexLocationSpec -up-|> locspec.LocationSpec
	main.Blacklist -up-|> proc.CpuArch
	main.OtherType -up-|> proc.CpuArch
	main.SomeType -up-|> proc.CpuArch
	main.asomething -up-|> pluginsupport.Something
	main.asomething -up-|> proc.CpuArch
	main.asomethingelse -up-|> pluginsupport.SomethingElse
	main.astruct -up-|> main.PRcvrable
	main.astruct -up-|> main.VRcvrable
	main.goVersion -up-|> proc.CpuArch
	md2man.roffRenderer -up-|> blackfriday.Renderer
	native.nativeProcess -up-|> proc.ProcessManipulation
	native.nativeThread -up-|> proc.MemoryReadWriter
	native.nativeThread -up-|> proc.MemoryReader
	packages.LoadMode -up-|> proc.CpuArch
	packages.Package -up-|> proc.CpuArch
	packages.loaderPackage -up-|> proc.CpuArch
	proc.Breakpoint -up-|> proc.CpuArch
	proc.BreakpointState -up-|> proc.CpuArch
	proc.Info -up-|> proc.ThreadInfo
	proc.MemoryReadWriter -up-|> proc.MemoryReader
	proc.PEMachine -up-|> proc.CpuArch
	proc.Process -up-|> proc.Info
	proc.Process -up-|> proc.ProcessManipulation
	proc.Process -up-|> proc.RecordingManipulation
	proc.Process -up-|> proc.ThreadInfo
	proc.StopReason -up-|> proc.CpuArch
	proc.Target -up-|> proc.Info
	proc.Target -up-|> proc.Process
	proc.Target -up-|> proc.ProcessManipulation
	proc.Target -up-|> proc.RecordingManipulation
	proc.Target -up-|> proc.ThreadInfo
	proc.compositeMemory -up-|> proc.MemoryReadWriter
	proc.compositeMemory -up-|> proc.MemoryReader
	proc.locationExpr -up-|> proc.CpuArch
	proc.memCache -up-|> proc.MemoryReadWriter
	proc.memCache -up-|> proc.MemoryReader
	proc.x86Inst -up-|> proc.archInst
	reader.Variable -up-|> godwarf.Entry
	resolve.Scope -up-|> proc.CpuArch
	resolve.block -up-|> proc.CpuArch
	rpc2.RPCClient -up-|> service.Client
	rpccommon.RPCCallback -up-|> service.RPCCallback
	rpccommon.ServerImpl -up-|> service.Server
	simplelru.LRU -up-|> simplelru.LRUCache
	span.TokenConverter -up-|> span.Converter
	syntax.AssignStmt -up-|> syntax.Node
	syntax.AssignStmt -up-|> syntax.Stmt
	syntax.BinaryExpr -up-|> syntax.Expr
	syntax.BinaryExpr -up-|> syntax.Node
	syntax.BranchStmt -up-|> syntax.Node
	syntax.BranchStmt -up-|> syntax.Stmt
	syntax.CallExpr -up-|> syntax.Expr
	syntax.CallExpr -up-|> syntax.Node
	syntax.Comprehension -up-|> syntax.Expr
	syntax.Comprehension -up-|> syntax.Node
	syntax.CondExpr -up-|> syntax.Expr
	syntax.CondExpr -up-|> syntax.Node
	syntax.DefStmt -up-|> syntax.Node
	syntax.DefStmt -up-|> syntax.Stmt
	syntax.DictEntry -up-|> syntax.Expr
	syntax.DictEntry -up-|> syntax.Node
	syntax.DictExpr -up-|> syntax.Expr
	syntax.DictExpr -up-|> syntax.Node
	syntax.DotExpr -up-|> syntax.Expr
	syntax.DotExpr -up-|> syntax.Node
	syntax.Expr -up-|> syntax.Node
	syntax.ExprStmt -up-|> syntax.Node
	syntax.ExprStmt -up-|> syntax.Stmt
	syntax.File -up-|> syntax.Node
	syntax.ForClause -up-|> syntax.Node
	syntax.ForStmt -up-|> syntax.Node
	syntax.ForStmt -up-|> syntax.Stmt
	syntax.Ident -up-|> syntax.Expr
	syntax.Ident -up-|> syntax.Node
	syntax.IfClause -up-|> syntax.Node
	syntax.IfStmt -up-|> syntax.Node
	syntax.IfStmt -up-|> syntax.Stmt
	syntax.IndexExpr -up-|> syntax.Expr
	syntax.IndexExpr -up-|> syntax.Node
	syntax.LambdaExpr -up-|> syntax.Expr
	syntax.LambdaExpr -up-|> syntax.Node
	syntax.ListExpr -up-|> syntax.Expr
	syntax.ListExpr -up-|> syntax.Node
	syntax.Literal -up-|> syntax.Expr
	syntax.Literal -up-|> syntax.Node
	syntax.LoadStmt -up-|> syntax.Node
	syntax.LoadStmt -up-|> syntax.Stmt
	syntax.ParenExpr -up-|> syntax.Expr
	syntax.ParenExpr -up-|> syntax.Node
	syntax.Position -up-|> proc.CpuArch
	syntax.ReturnStmt -up-|> syntax.Node
	syntax.ReturnStmt -up-|> syntax.Stmt
	syntax.SliceExpr -up-|> syntax.Expr
	syntax.SliceExpr -up-|> syntax.Node
	syntax.Stmt -up-|> syntax.Node
	syntax.Token -up-|> proc.CpuArch
	syntax.TupleExpr -up-|> syntax.Expr
	syntax.TupleExpr -up-|> syntax.Node
	syntax.UnaryExpr -up-|> syntax.Expr
	syntax.UnaryExpr -up-|> syntax.Node
	syntax.WhileStmt -up-|> syntax.Node
	syntax.WhileStmt -up-|> syntax.Stmt
	syscall.Signal -up-|> proc.CpuArch
	util.UnknownFormat -up-|> util.dataFormat
	version.Version -up-|> proc.CpuArch
	x86asm.Arg -up-|> proc.CpuArch
	x86asm.Imm -up-|> proc.CpuArch
	x86asm.Imm -up-|> x86asm.Arg
	x86asm.Inst -up-|> proc.CpuArch
	x86asm.Mem -up-|> proc.CpuArch
	x86asm.Mem -up-|> x86asm.Arg
	x86asm.Op -up-|> proc.CpuArch
	x86asm.Prefix -up-|> proc.CpuArch
	x86asm.Reg -up-|> proc.CpuArch
	x86asm.Reg -up-|> x86asm.Arg
	x86asm.Rel -up-|> proc.CpuArch
	x86asm.Rel -up-|> x86asm.Arg

package "proc" {
	note as N_proc_BreakpointKind
		<b>BreakpointKind</b>

		NextBreakpoint
		NextDeferBreakpoint
		StepBreakpoint
		UserBreakpoint
	end note
}
N_proc_BreakpointKind --> proc.BreakpointKind
package "api" {
	note as N_api_AssemblyFlavour
		<b>AssemblyFlavour</b>

		GNUFlavour
		GoFlavour
		IntelFlavour
	end note
}
N_api_AssemblyFlavour --> api.AssemblyFlavour
package "elf" {
	note as N_elf_NType
		<b>NType</b>

		_NT_AUXV
		_NT_FILE
		_NT_FPREGSET
		_NT_X86_XSTATE
	end note
}
N_elf_NType --> elf.NType
package "main" {
	note as N_main_BitFieldType
		<b>BitFieldType</b>

		bitFour
		bitOne
		bitThree
		bitTwo
		bitZero
	end note
}
N_main_BitFieldType --> main.BitFieldType
package "resolve" {
	note as N_resolve_Scope
		<b>Scope</b>

		Cell
		Free
		Global
		Local
		Predeclared
		Undefined
		Universal
	end note
}
N_resolve_Scope --> resolve.Scope
package "dwarfbuilder" {
	note as N_dwarfbuilder_Form
		<b>Form</b>

		DW_FORM_addr
		DW_FORM_block
		DW_FORM_block1
		...
	end note
}
N_dwarfbuilder_Form --> dwarfbuilder.Form
package "x86asm" {
	note as N_x86asm_Prefix
		<b>Prefix</b>

		PrefixAddr16
		PrefixAddr32
		PrefixAddrSize
		...
	end note
}
N_x86asm_Prefix --> x86asm.Prefix
package "liner" {
	note as N_liner_action
		<b>action</b>

		altB
		altF
		altY
		del
		...
	end note
}
N_liner_action --> liner.action
package "packages" {
	note as N_packages_ErrorKind
		<b>ErrorKind</b>

		ListError
		ParseError
		TypeError
		UnknownError
	end note
}
N_packages_ErrorKind --> packages.ErrorKind
package "api" {
	note as N_api_StacktraceOptions
		<b>StacktraceOptions</b>

		StacktraceG
		StacktraceReadDefers
		StacktraceSimple
	end note
}
N_api_StacktraceOptions --> api.StacktraceOptions
package "op" {
	note as N_op_Opcode
		<b>Opcode</b>

		DW_OP_abs
		DW_OP_addr
		DW_OP_and
		...
		DW_OP_xderef
		DW_OP_xderef_size
		DW_OP_xor
	end note
}
N_op_Opcode --> op.Opcode
package "native" {
	note as N_native_trapWaitOptions
		<b>trapWaitOptions</b>

		trapWaitDontCallExitGuard
		trapWaitHalt
		trapWaitNohang
	end note
}
N_native_trapWaitOptions --> native.trapWaitOptions
package "compile" {
	note as N_compile_Opcode
		<b>Opcode</b>

		AMP
		APPEND
		ATTR
		CALL
		...
	end note
}
N_compile_Opcode --> compile.Opcode
package "proc" {
	note as N_proc_Direction
		<b>Direction</b>

		Backward
		Forward
	end note
}
N_proc_Direction --> proc.Direction
package "reader" {
	note as N_reader_VariablesFlags
		<b>VariablesFlags</b>

		VariablesOnlyVisible
		VariablesSkipInlinedSubroutines
		VariablesTrustDeclLine
	end note
}
N_reader_VariablesFlags --> reader.VariablesFlags
package "syntax" {
	note as N_syntax_Mode
		<b>Mode</b>

		RetainComments
	end note
}
N_syntax_Mode --> syntax.Mode
package "terminal" {
	note as N_terminal_commandGroup
		<b>commandGroup</b>

		breakCmds
		dataCmds
		goroutineCmds
		otherCmds
		runCmds
		stackCmds
	end note
}
N_terminal_commandGroup --> terminal.commandGroup
package "pflag" {
	note as N_pflag_ErrorHandling
		<b>ErrorHandling</b>

		ContinueOnError
		ExitOnError
		PanicOnError
	end note
}
N_pflag_ErrorHandling --> pflag.ErrorHandling
package "arm64asm" {
	note as N_arm64asm_ExtShift
		<b>ExtShift</b>

		asr
		lsl
		lsr
		...
	end note
}
N_arm64asm_ExtShift --> arm64asm.ExtShift
package "test" {
	note as N_test_BuildFlags
		<b>BuildFlags</b>

		AllNonOptimized
		BuildModePIE
		BuildModePlugin
		EnableCGOOptimization
		EnableDWZCompression
		EnableInlining
		EnableOptimization
		LinkStrip
	end note
}
N_test_BuildFlags --> test.BuildFlags
package "starlark" {
	note as N_starlark_Bool
		<b>Bool</b>

		False
		True
	end note
}
N_starlark_Bool --> starlark.Bool
package "logrus" {
	note as N_logrus_Level
		<b>Level</b>

		DebugLevel
		ErrorLevel
		FatalLevel
		InfoLevel
		PanicLevel
		TraceLevel
		WarnLevel
	end note
}
N_logrus_Level --> logrus.Level
package "dwarfbuilder" {
	note as N_dwarfbuilder_Encoding
		<b>Encoding</b>

		DW_ATE_UTF
		DW_ATE_address
		DW_ATE_boolean
		...
	end note
}
N_dwarfbuilder_Encoding --> dwarfbuilder.Encoding
package "main" {
	note as N_main_ConstType
		<b>ConstType</b>

		constOne
		constThree
		constTwo
		constZero
	end note
}
N_main_ConstType --> main.ConstType
package "proc" {
	note as N_proc_AssemblyFlavour
		<b>AssemblyFlavour</b>

		GNUFlavour
		GoFlavour
		IntelFlavour
	end note
}
N_proc_AssemblyFlavour --> proc.AssemblyFlavour
package "proc" {
	note as N_proc_variableFlags
		<b>variableFlags</b>

		VariableArgument
		VariableCPtr
		VariableConstant
		VariableEscaped
		VariableFakeAddress
		VariableReturnArgument
		VariableShadowed
	end note
}
N_proc_variableFlags --> proc.variableFlags
package "frame" {
	note as N_frame_Rule
		<b>Rule</b>

		RuleArchitectural
		RuleCFA
		RuleExpression
		RuleFramePointer
		RuleOffset
		RuleRegister
		RuleSameVal
		RuleUndefined
		RuleValExpression
		RuleValOffset
	end note
}
N_frame_Rule --> frame.Rule
package "liner" {
	note as N_liner_TabStyle
		<b>TabStyle</b>

		TabCircular
		TabPrints
	end note
}
N_liner_TabStyle --> liner.TabStyle
package "terminal" {
	note as N_terminal_cmdPrefix
		<b>cmdPrefix</b>

		deferredPrefix
		noPrefix
		onPrefix
		revPrefix
	end note
}
N_terminal_cmdPrefix --> terminal.cmdPrefix
package "syscall" {
	note as N_syscall_Errno
		<b>Errno</b>

		APPMODEL_ERROR_DYNAMIC_PROPERTY_INVALID
		APPMODEL_ERROR_DYNAMIC_PROPERTY_READ_FAILED
		APPMODEL_ERROR_NO_APPLICATION
		...
	end note
}
N_syscall_Errno --> syscall.Errno
package "x86asm" {
	note as N_x86asm_Op
		<b>Op</b>

		AAA
		AAD
		AAM
		...
	end note
}
N_x86asm_Op --> x86asm.Op
package "x86asm" {
	note as N_x86asm_decodeOp
		<b>decodeOp</b>

		xArg1
		xArg3
		xArgAL
		...
	end note
}
N_x86asm_decodeOp --> x86asm.decodeOp
package "blackfriday" {
	note as N_blackfriday_linkType
		<b>linkType</b>

		linkDeferredFootnote
		linkImg
		linkInlineFootnote
		linkNormal
	end note
}
N_blackfriday_linkType --> blackfriday.linkType
package "proc" {
	note as N_proc_StopReason
		<b>StopReason</b>

		StopAttached
		StopBreakpoint
		StopCallReturned
		StopExited
		StopHardcodedBreakpoint
		StopLaunched
		StopManual
		StopNextFinished
		StopUnknown
	end note
}
N_proc_StopReason --> proc.StopReason
package "gcimporter" {
	note as N_gcimporter_itag
		<b>itag</b>

		arrayType
		chanType
		definedType
		interfaceType
		mapType
		pointerType
		signatureType
		sliceType
		structType
	end note
}
N_gcimporter_itag --> gcimporter.itag
package "argv" {
	note as N_argv_TokenType
		<b>TokenType</b>

		TokBackQuote
		TokEOF
		TokPipe
		TokSpace
		TokString
		TokStringDoubleQuote
		TokStringSingleQuote
	end note
}
N_argv_TokenType --> argv.TokenType
package "debugger" {
	note as N_debugger_ExecuteKind
		<b>ExecuteKind</b>

		ExecutingExistingFile
		ExecutingGeneratedFile
		ExecutingGeneratedTest
		ExecutingOther
	end note
}
N_debugger_ExecuteKind --> debugger.ExecuteKind
package "x86asm" {
	note as N_x86asm_Reg
		<b>Reg</b>

		AH
		AL
		AX
		...
		regMax
	end note
}
N_x86asm_Reg --> x86asm.Reg
package "proc" {
	note as N_proc_AsmInstructionKind
		<b>AsmInstructionKind</b>

		CallInstruction
		HardBreakInstruction
		JmpInstruction
		OtherInstruction
		RetInstruction
	end note
}
N_proc_AsmInstructionKind --> proc.AsmInstructionKind
package "proc" {
	note as N_proc_floatSpecial
		<b>floatSpecial</b>

		FloatIsNaN
		FloatIsNegInf
		FloatIsNormal
		FloatIsPosInf
	end note
}
N_proc_floatSpecial --> proc.floatSpecial
package "terminal" {
	note as N_terminal_frameDirection
		<b>frameDirection</b>

		frameDown
		frameSet
		frameUp
	end note
}
N_terminal_frameDirection --> terminal.frameDirection
package "line" {
	note as N_line_opcodeKind
		<b>opcodeKind</b>

		extendedOpcode
		specialOpcode
		standardOpcode
	end note
}
N_line_opcodeKind --> line.opcodeKind
package "native" {
	note as N_native_waitForDebugEventFlags
		<b>waitForDebugEventFlags</b>

		waitBlocking
		waitDontHandleExceptions
		waitSuspendNewThreads
	end note
}
N_native_waitForDebugEventFlags --> native.waitForDebugEventFlags
package "starlark" {
	note as N_starlark_Side
		<b>Side</b>

		Left
		Right
	end note
}
N_starlark_Side --> starlark.Side
package "packages" {
	note as N_packages_LoadMode
		<b>LoadMode</b>

		LoadAllSyntax
		LoadFiles
		LoadImports
		LoadSyntax
		LoadTypes
		NeedCompiledGoFiles
		NeedDeps
		NeedExportsFile
		NeedFiles
		NeedImports
		NeedName
		NeedSyntax
		NeedTypes
		NeedTypesInfo
		NeedTypesSizes
	end note
}
N_packages_LoadMode --> packages.LoadMode
package "gopathwalk" {
	note as N_gopathwalk_RootType
		<b>RootType</b>

		RootCurrentModule
		RootGOPATH
		RootGOROOT
		RootModuleCache
		RootOther
		RootUnknown
	end note
}
N_gopathwalk_RootType --> gopathwalk.RootType
package "proc" {
	note as N_proc_StacktraceOptions
		<b>StacktraceOptions</b>

		StacktraceG
		StacktraceReadDefers
		StacktraceSimple
	end note
}
N_proc_StacktraceOptions --> proc.StacktraceOptions
package "liner" {
	note as N_liner_tabDirection
		<b>tabDirection</b>

		tabForward
		tabReverse
	end note
}
N_liner_tabDirection --> liner.tabDirection
package "time" {
	note as N_time_Duration
		<b>Duration</b>

		quantum
		heartbeatInterval
	end note
}
N_time_Duration --> time.Duration
package "dwarf" {
	note as N_dwarf_Attr
		<b>Attr</b>

		AttrGoElem
		AttrGoEmbeddedField
		AttrGoKey
		AttrGoKind
		AttrGoPackageName
		AttrGoRuntimeType
	end note
}
N_dwarf_Attr --> dwarf.Attr
package "syntax" {
	note as N_syntax_Token
		<b>Token</b>

		AMP
		AMP_EQ
		AND
		BREAK
		...
	end note
}
N_syntax_Token --> syntax.Token
@enduml
