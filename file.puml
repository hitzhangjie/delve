@startuml

package "frame" {
	class "CommonInformationEntry" as frame.CommonInformationEntry <<V,Orchid>> {
		+Length: uint32
		+CIE_id: uint32
		+Version: uint8
		+Augmentation: string
		+CodeAlignmentFactor: uint64
		+DataAlignmentFactor: int64
		+ReturnAddressRegister: uint64
		+InitialInstructions: []byte
		-staticBase: uint64
	}
}

package "frame" {
	class "DWRule" as frame.DWRule <<V,Orchid>> {
		+Rule: frame.Rule
		+Offset: int64
		+Reg: uint64
		+Expression: []byte
	}
}

	frame.DWRule --> frame.Rule

package "frame" {
	class "FrameContext" as frame.FrameContext <<E,#FFCC00>> {
		-loc: uint64
		-order: binary.ByteOrder
		-address: uint64
		+CFA: frame.DWRule
		+Regs: map[uint64]frame.DWRule
		-initialRegs: map[uint64]frame.DWRule
		-cie: *frame.CommonInformationEntry
		+RetAddrReg: uint64
		-codeAlignment: uint64
		-dataAlignment: int64
		-executeDwarfProgram()
		+ExecuteUntilPC(instructions: []byte)
	}
}

	frame.FrameContext --> frame.DWRule
	frame.FrameContext --> frame.CommonInformationEntry

package "frame" {
	class "FrameDescriptionEntries" as frame.FrameDescriptionEntries <<V,Orchid>> {
		+FDEForPC(pc: uint64): (*frame.FrameDescriptionEntry, error)
		+Append(otherFDEs: frame.FrameDescriptionEntries): frame.FrameDescriptionEntries
	}
}

	frame.FrameDescriptionEntries ..> frame.FrameDescriptionEntry : <<return>>
	frame.FrameDescriptionEntries ..> frame.FrameDescriptionEntries

package "frame" {
	class "FrameDescriptionEntry" as frame.FrameDescriptionEntry <<V,Orchid>> {
		+Length: uint32
		+CIE: *frame.CommonInformationEntry
		+Instructions: []byte
		-begin: uint64
		-size: uint64
		-order: binary.ByteOrder
		+Cover(addr: uint64): bool
		+Begin(): uint64
		+End(): uint64
		+EstablishFrame(pc: uint64): *frame.FrameContext
	}
}

	frame.FrameDescriptionEntry --> frame.CommonInformationEntry
	frame.FrameDescriptionEntry ..> frame.FrameContext : <<return>>

package "frame" {
	class "Rule" as frame.Rule <<V,Orchid>>
}

package "frame" {
	class "parseContext" as frame.parseContext <<V,Orchid>> {
		-staticBase: uint64
		-entries: frame.FrameDescriptionEntries
		-common: *frame.CommonInformationEntry
		-frame: *frame.FrameDescriptionEntry
		-length: uint32
		-ptrSize: int
	}
}

	frame.parseContext --> frame.FrameDescriptionEntries
	frame.parseContext --> frame.CommonInformationEntry
	frame.parseContext --> frame.FrameDescriptionEntry

package "proc" {
	class "Ancestor" as proc.Ancestor <<V,Orchid>> {
		+ID: int64
		+Unreadable: error
		-pcsVar: *proc.Variable
		+Stack(n: int): ([]proc.Stackframe, error)
	}
}

	proc.Ancestor --> proc.Variable
	proc.Ancestor ..> proc.Stackframe : <<return>>

package "proc" {
	class "Arch" as proc.Arch <<V,Orchid>> {
		+Name: string
		+RegistersToDwarfRegisters: op.DwarfRegisters
		+DwarfRegisterToString: op.DwarfRegister) (string, bool, string)
		+PtrSize(): int
		+MaxInstructionLength(): int
		+BreakpointInstruction(): []byte
		+AltBreakpointInstruction(): []byte
		+BreakInstrMovesPC(): bool
		+BreakpointSize(): int
		+DerefTLS(): bool
	}
}

	proc.Arch --> proc.opcodeSeq
	proc.Arch --> proc.Function

package "proc" {
	class "BinaryInfo" as proc.BinaryInfo <<E,#FFCC00>> {
		+Arch: *proc.Arch
		+GOOS: string
		+Functions: []proc.Function
		+Sources: []string
		+LookupFunc: map[string]*proc.Function
		+SymNames: elf.Symbol
		+Images: []*proc.Image
		+ElfDynamicSection: proc.ElfDynamicSection
		+PackageMap: map[string][]string
		+LoadBinaryInfo(path: string, entryPoint: uint64, debugInfoDirs: []string): error
		+GStructOffset(): uint64
		+...
	}
}

package "proc" {
	class "Breakpoint" as proc.Breakpoint <<V,Orchid>> {
		+FunctionName: string
		+File: string
		+Line: int
		+Addr: uint64
		+OriginalData: []byte
		+Name: string
		+LogicalID: int
		+Kind: proc.BreakpointKind
		+Tracepoint: bool
		+TraceReturn: bool
		+Goroutine: bool
		+Stacktrace: int
		+Variables: []string
		+HitCount: map[int]uint64
		+TotalHitCount: uint64
		+DeferReturns: []uint64
		+Cond: ast.Expr
	}
}

	proc.Breakpoint ..> proc.Thread : <<use>>

package "proc" {
	class "BreakpointMap" as proc.BreakpointMap <<V,Orchid>> {
		+M: map[uint64]*proc.Breakpoint
		-breakpointIDCounter: int
		-internalBreakpointIDCounter: int
		+HasInternalBreakpoints(): bool
	}
}

package "proc" {
	class "CommonThread" as proc.CommonThread <<V,Orchid>> {
		+CallReturn: bool
		-returnValues: []*proc.Variable
		-g: *proc.G
	}
}

	proc.CommonThread --> proc.G

package "proc" {
	class "Function" as proc.Function <<V,Orchid>> {
		+Name: string
		+Entry: uint64
		+End: uint64
		-offset: dwarf.Offset
		-cu: *proc.compileUnit
		+InlinedCalls: []proc.InlinedCall
		-fakeType(bi: *proc.BinaryInfo, removeReceiver: bool): (godwarf.FuncType, error)
		+PackageName(): string
		+ReceiverName(): string
		+BaseName(): string
		+Optimized(): bool
		+PrologueEndPC(): uint64
		-exportedRuntime(): bool
		-privateRuntime(): bool
	}
}

	proc.Function --> proc.compileUnit
	proc.Function --> proc.InlinedCall

package "proc" {
	class "G" as proc.G <<E,#FFCC00>> {
		+ID: int
		+PC: uint64
		+SP: uint64
		+...
	}
}

	proc.G --> proc.Variable
	proc.G --> proc.stack
	proc.G --> proc.Location
	proc.G --> proc.Thread
	proc.G ..> proc.Stackframe : <<return>>

package "proc" {
	interface "Info" as proc.Info {
		+BinInfo(): *proc.BinaryInfo
		+EntryPoint(): (uint64, error)
		+FindThread(threadID: int): (proc.Thread, bool)
		+Pid(): int
		+ResumeNotify(: chan<- struct{})
		+ThreadList(): []proc.Thread
		+Valid(): (bool, error)
	}
}

	proc.Info ..> proc.BinaryInfo : <<return>>
	proc.Info ..> proc.Thread : <<return>>

package "proc" {
	class "InlinedCall" as proc.InlinedCall <<V,Orchid>> {
		-cu: *proc.compileUnit
		+LowPC: uint64
		+HighPC: uint64
	}
}

	proc.InlinedCall --> proc.compileUnit

package "proc" {
	class "Location" as proc.Location <<V,Orchid>> {
		+PC: uint64
		+File: string
		+Line: int
		+Fn: *proc.Function
	}
}

	proc.Location --> proc.Function

package "proc" {
	interface "MemoryReadWriter" as proc.MemoryReadWriter {
		+ReadMemory(buf: []byte, addr: uint64): (n: int, err: error)
		+WriteMemory(addr: uint64, data: []byte): (written: int, err: error)
	}
}

package "proc" {
	interface "MemoryReader" as proc.MemoryReader {
		+ReadMemory(buf: []byte, addr: uint64): (n: int, err: error)
	}
}

package "proc" {
	interface "Process" as proc.Process {
		+BinInfo(): *proc.BinaryInfo
		+Breakpoints(): *proc.BreakpointMap
		+CheckAndClearManualStopRequest(): bool
		+EntryPoint(): (uint64, error)
		+FindThread(threadID: int): (proc.Thread, bool)
		+Memory(): proc.MemoryReadWriter
		+Pid(): int
		+Recorded(): (recorded: bool, tracedir: string)
		+RequestManualStop(): error
		+ResumeNotify(: chan<- struct{})
		+ThreadList(): []proc.Thread
		+Valid(): (bool, error)
		+When(): (string, error)
	}
}

	proc.Process ..> proc.BinaryInfo : <<return>>
	proc.Process ..> proc.BreakpointMap : <<return>> 
	proc.Process ..> proc.Thread : <<return>>
	proc.Process ..> proc.MemoryReadWriter : <<return>>

package "proc" {
	interface "ProcessInternal" as proc.ProcessInternal {
		+ContinueOnce() ...
		+Detach(: bool): error
		+EraseBreakpoint(: *proc.Breakpoint): error
		+Restart(pos: string): (proc.Thread, error)
		+WriteBreakpoint(addr: uint64) ...
	}
}

	proc.ProcessInternal ..> proc.Thread : <<return>>
	proc.ProcessInternal ..> proc.Breakpoint : <<use>>
	proc.ProcessInternal ..> proc.Function : <<return>>

package "proc" {
	class "Stackframe" as proc.Stackframe <<V,Orchid>> {
		+Current: proc.Location
		+Call: proc.Location
		+Regs: op.DwarfRegisters
		+Ret: uint64
		+SystemStack: bool
		+Inlined: bool
		+Bottom: bool
		+TopmostDefer: *proc.Defer
		+Defers: []*proc.Defer
		+FrameOffset(): int64
		+FramePointerOffset(): int64
	}
}

	proc.Stackframe --> proc.Location

package "proc" {
	class "Target" as proc.Target <<E,#FFCC00>> {
		+Process: proc.Process
		+StopReason: proc.StopReason
		+Next(): err: error
		+Continue(): error
		+Step(): err: error
		+StepOut(): error
		+StepInstruction(): err: error
		+SupportsFunctionCalls(): bool
		+ClearAllGCache()
		+Restart(from: string): error
		+SelectedGoroutine(): *proc.G
		+SwitchGoroutine(g: *proc.G): error
		+SwitchThread(tid: int): error
		+Detach(kill: bool): error
		+CurrentThread(): proc.Thread
		+SetBreakpoint(...)
		+ClearBreakpoint(...)
		+ClearInternalBreakpoints(): error
	}
}

	proc.Target --> proc.ProcessInternal
	proc.Target --> proc.Thread
	proc.Target --> proc.G
	proc.Target ..> proc.Breakpoint : <<return>>

package "proc" {
	interface "Thread" as proc.Thread {
		+BinInfo(): *proc.BinaryInfo
		+Breakpoint(): *proc.BreakpointState
		+Common(): *proc.CommonThread
		+Location(): (*proc.Location, error)
		+ProcessMemory(): proc.MemoryReadWriter
		+Registers(): (proc.Registers, error)
		+RestoreRegisters(: proc.Registers): error
		+SetCurrentBreakpoint(adjustPC: bool): error
		+SetDX(: uint64): error
		+SetPC(: uint64): error
		+SetSP(: uint64): error
		+StepInstruction(): error
		+ThreadID(): int
	}
}

	proc.Thread ..> proc.BinaryInfo : <<return>>
	proc.Thread ..> proc.CommonThread : <<return>>
	proc.Thread ..> proc.Location : <<return>> 
	proc.Thread ..> proc.MemoryReadWriter : <<return>>

package "proc" {
	interface "ThreadInfo" as proc.ThreadInfo {
		+FindThread(threadID: int): (proc.Thread, bool)
		+ThreadList(): []proc.Thread
	}
}

	proc.ThreadInfo ..> proc.Thread : <<return>>

package "proc" {
	class "Variable" as proc.Variable <<E,#FFCC00>> {
		+Addr: uint64
		+OnlyAddr: bool
		+Name: string
		+DwarfType: godwarf.Type
		+RealType: godwarf.Type
		+Kind: reflect.Kind
		+Value: constant.Value
		+FloatSpecial: proc.floatSpecial
		+Len: int64
		+Cap: int64
		+Flags: proc.variableFlags
		+Base: uint64
		+Children: []proc.Variable
		+Unreadable: error
		+LocationExpr: *proc.locationExpr
		+DeclLine: int64
		+TypeString(): string
		+ConstDescr(): string
	}
}

	proc.Variable --> proc.MemoryReadWriter
	proc.Variable --> proc.BinaryInfo
	proc.Variable --> proc.floatSpecial
	proc.Variable --> proc.locationExpr

package "proc" {
	class "compileUnit" as proc.compileUnit <<V,Orchid>> {
		-name: string
		+Version: uint8
		-lowPC: uint64
		-ranges: [][2]uint64
		-entry: dwarf.Entry
		-isgo: bool
		-lineInfo: line.DebugLineInfo
		-optimized: bool
		-producer: string
		-offset: dwarf.Offset
		-image: *proc.Image
	}
}

	proc.compileUnit -up-> line.DebugLineInfo
	proc.compileUnit --> proc.Image

package "proc" {
	class "functionsDebugInfoByEntry" as proc.functionsDebugInfoByEntry <<V,Orchid>> {
		+Len(): int
		+Less(i: int, j: int): bool
		+Swap(i: int, j: int)
	}
}

proc.functionsDebugInfoByEntry *-- proc.Function

package "proc" {
	class "locationExpr" as proc.locationExpr <<V,Orchid>> {
		-isBlock: bool
		-isEscaped: bool
		-off: int64
		-pc: uint64
		-instr: []byte
		+String(): string
	}
}

package "proc" {
	class "stack" as proc.stack <<V,Orchid>> {
		-hi: uint64
		-lo: uint64
	}
}

package "core" {
	interface "osThread" as core.osThread {
		-pid(): int
		-registers(): (proc.Registers, error)
	}
}

package "core" {
	class "process" as core.process <<E,#FFCC00>> {
		+Threads: map[int]*core.thread
		+BinInfo(): proc.BinaryInfo
		+EntryPoint(): (uint64, error)
		+WriteBreakpoint(addr: uint64) ...
		+Recorded(): (bool, string)
		+Restart(: string): (proc.Thread, error)
		+When(): (string, error)
		+ReadMemory(data: []byte, addr: uint64): (n: int, err: error)
		+WriteMemory(addr: uint64, data: []byte): (int, error)
		+Breakpoints(): proc.BreakpointMap
		+EraseBreakpoint(bp: proc.Breakpoint): error
		+ClearInternalBreakpoints(): error
		+ContinueOnce(): (proc.Thread, proc.StopReason, error)
		+StepInstruction(): error
		+RequestManualStop(): error
		+CheckAndClearManualStopRequest(): bool
		+Memory(): proc.MemoryReadWriter
		+Detach(: bool): error
		+Valid(): (bool, error)
		+Pid(): int
		+ResumeNotify(: chan<- struct{})
		+ThreadList(): proc.Thread
		+FindThread(threadID: int): (proc.Thread, bool)
	}
}

	core.process --> proc.MemoryReader
	core.process ..> proc.MemoryReadWriter

	core.process --> proc.BinaryInfo
	core.process -up-> proc.BreakpointMap
	core.process ..> proc.Function : <<return>>
	core.process ..> proc.Thread
	core.process ..> proc.Breakpoint : <<use>>

package "core" {
	class "thread" as core.thread <<E,#FFCC00>> {
		-th: core.osThread
		-p: *core.process
		-common: proc.CommonThread
		+ProcessMemory(): proc.MemoryReadWriter
		+Location(): (proc.Location, error)
		+Breakpoint(): proc.BreakpointState
		+ThreadID(): int
		+Registers(): (proc.Registers, error)
		+RestoreRegisters(: proc.Registers): error
		+BinInfo(): proc.BinaryInfo
		+StepInstruction(): error
		+Blocked(): bool
		+SetCurrentBreakpoint(adjustPC: bool): error
		+Common(): proc.CommonThread
		+SetPC(: uint64): error
		+SetSP(: uint64): error
		+SetDX(: uint64): error
	}
}

	core.thread --> core.osThread
	core.thread --> proc.CommonThread
	core.thread ..> proc.MemoryReadWriter : <<return>>
	core.thread ..> proc.Location : <<return>> 
	core.thread ..> proc.BinaryInfo : <<return>>

package "debugger" {
	class "Debugger" as debugger.Debugger <<E,#FFCC00>> {
		+Launch(processArgs: []string, wd: string): (proc.Target, error)
		+Attach(pid: int, path: string): (proc.Target, error)
		+ProcessPid(): int
		+FunctionReturnLocations(fnName: string): ([]uint64, error)
		+Detach(kill: bool): error
		+State(nowait: bool): (api.DebuggerState, error)
		+CreateBreakpoint(requestedBp: api.Breakpoint) ...
		+ClearBreakpoint(requestedBp: api.Breakpoint) ...
		+Breakpoints(): api.Breakpoint
		+FindBreakpoint(id: int): api.Breakpoint
		+Threads(): (proc.Thread, error)
		+FindThread(id: int): (proc.Thread, error)
		+Command(command: api.DebuggerCommand): (api.DebuggerState, error)
		+Sources(filter: string): ([]string, error)
		+Functions(filter: string): ([]string, error)
		+Types(filter: string): ([]string, error)
		+ThreadRegisters(threadID: int...) ...
		+ScopeRegisters(goid: int, frame: int...) ...
		+LocalVariables(goid: int, frame: int...) ...
		+FunctionArguments(goid: int, frame: int ...) ...
		+EvalVariableInScope(goid, frame, symbol...)
		+SetVariableInScope(goid, frame, symbol, value) ...
		+Goroutines(start: int, count: int): (proc.G, int, error)
		+Stacktrace(goroutineID: int, depth: int ...) ...
		+Disassemble(goroutineID: int, addr1: uint64...) ...
		+ExamineMemory(address: uint64, length: int) ...
	}
}

	debugger.Debugger -down-> proc.Target

	proc.MemoryReadWriter -up-|> proc.MemoryReader
	proc.Info --|> proc.ThreadInfo
	proc.Process -up-|> proc.Info
	proc.Target -up-|> proc.Process

@enduml

